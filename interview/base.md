# 基础知识

## http 和 https 的区别?

HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）的主要区别在于HTTPS是HTTP的安全版本。以下是它们之间的关键区别：

1. **加密**：
   - **HTTP**：不加密，数据以明文形式传输，这意味着数据在传输过程中可以被任何拦截者读取。
   - **HTTPS**：通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议加密数据，确保数据传输的安全性。这使得即便数据被拦截，也无法被读取。

2. **端口**：
   - **HTTP**：默认使用80端口。
   - **HTTPS**：默认使用443端口。

3. **性能**：
   - **HTTP**：没有加密/解密的开销，理论上讲比HTTPS快。
   - **HTTPS**：由于数据加密的过程，可能会稍微慢一些，但随着计算能力的提高和优化，这种差异越来越小。

4. **安全性**：
   - **HTTP**：不提供数据完整性验证，无法验证数据是否在传输过程中被篡改。
   - **HTTPS**：提供数据完整性验证，可以检测数据在传输过程中是否被篡改。

5. **搜索引擎优化（SEO）**：
   - **HTTP**：不利于SEO，因为Google等搜索引擎倾向于对安全网站进行排名。
   - **HTTPS**：可以提升SEO排名。

6. **证书**：
   - **HTTP**：不需要证书。
   - **HTTPS**：需要SSL/TLS证书来验证服务器的身份，这也是为什么HTTPS比HTTP更可信。

7. **隐私**：
   - **HTTP**：由于不加密，敏感信息（如密码、信用卡号等）可以被第三方轻易获取。
   - **HTTPS**：保护用户数据隐私，防止敏感信息被窃取。

在如今的网络环境中，HTTPS已经成为新的标准，特别是对于涉及用户数据或敏感交易的网站。大多数现代浏览器也会对HTTP网站标记为“不安全”，进一步推动网站所有者采用HTTPS。


## tcp 和 udp 的区别


TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种不同的传输层协议，它们用于在网络中传输数据，但是各自的特性和用途有所不同。以下是TCP和UDP的主要区别：

1. **连接**：
   - **TCP**：是一种面向连接的协议，这意味着在数据传输之前，必须在发送方和接收方之间建立连接。TCP通过三次握手过程建立连接。
   - **UDP**：是一种无连接协议，不需要建立连接就可以发送数据。

2. **可靠性**：
   - **TCP**：提供可靠的数据传输服务。它通过序列号、确认应答、重传机制以及流量控制等手段确保数据完整性和正确性。
   - **UDP**：不保证数据的可靠传输。它发送数据时不进行校验，也不保证数据包的顺序，可能会出现丢包、重复或乱序。

3. **速度和效率**：
   - **TCP**：由于需要建立连接、进行数据校验和确认，所以相对于UDP来说速度较慢，效率较低。
   - **UDP**：由于不需要建立连接、不保证顺序和可靠性，所以通常比TCP快，尤其适用于对实时性要求高的应用，如视频会议、直播等。

4. **数据流**：
   - **TCP**：提供字节流服务。发送的是一连串的字节，接收方需要根据序列号重新组装数据。
   - **UDP**：提供数据报服务。每个UDP数据包（称为数据报）都是独立传输的，且具有完整的地址信息。

5. **头部开销**：
   - **TCP**：头部至少20字节，包含众多控制信息，如序列号、确认应答号、数据偏移、控制位、窗口大小等。
   - **UDP**：头部只有8字节，包括源端口号、目的端口号、长度和校验和。

6. **拥塞控制**：
   - **TCP**：有拥塞控制机制，能够根据网络状况调整数据传输速率，避免网络拥塞。
   - **UDP**：没有拥塞控制，即使网络状况不佳，也会以相同的速率发送数据。

7. **用例**：
   - **TCP**：适用于需要高可靠性的应用，如网页浏览、文件传输、电子邮件等。
   - **UDP**：适用于实时应用，如在线游戏、语音和视频通话、DNS查询等。

在选择TCP和UDP时，通常需要根据应用的具体需求来决定使用哪一种协议。需要可靠性和顺序保证时选用TCP，需要速度和效率时选用UDP。


## DNS 如何工作


域名系统（DNS）是互联网的一项核心服务，它负责将人类可读的域名（如 `www.example.com`）转换成机器可读的IP地址（如 `192.0.2.1`）。这个过程称为域名解析。以下是DNS的工作流程：

1. **用户发起请求**：
   用户在浏览器中输入一个网址（例如 `www.example.com`），然后浏览器会发起一个DNS查询请求。

2. **操作系统查询**：
   首先，操作系统会检查本地DNS缓存是否有该域名的记录。如果有，就直接使用这个记录。如果没有，操作系统会向配置的DNS服务器发起请求。

3. **本地DNS服务器**：
   如果本地DNS缓存没有找到相应的记录，操作系统会查询本地DNS服务器。这通常是由用户的互联网服务提供商（ISP）提供的。

4. **根DNS服务器**：
   如果本地DNS服务器也没有缓存该域名的记录，它会向根DNS服务器发起查询。根DNS服务器是最高级别的DNS服务器，它会指向更具体的顶级域DNS服务器（例如 `.com`、`.net`、`.org` 等）。

5. **顶级域（TLD）服务器**：
   根DNS服务器会返回指向相应顶级域DNS服务器的响应。本地DNS服务器随后向这个TLD DNS服务器发起查询。

6. **权威DNS服务器**：
   TLD DNS服务器会指向负责该域名区域的权威DNS服务器。本地DNS服务器再向该权威DNS服务器发起查询请求。

7. **IP地址响应**：
   权威DNS服务器存储了域名到IP地址的映射信息。它会将对应的IP地址响应给本地DNS服务器。

8. **缓存和响应**：
   本地DNS服务器接收到IP地址后，它会对这个信息进行缓存以备后续查询使用，并将IP地址返回给用户的操作系统。

9. **浏览器发起连接**：
   操作系统将IP地址传递给浏览器，浏览器随后可以使用这个IP地址通过HTTP或HTTPS协议发起对目标服务器的连接请求。

10. **网站加载**：
    服务器响应浏览器的请求，并发送网页数据回用户的电脑，浏览器接收数据并显示网页内容。

DNS查询过程中可以使用递归查询和迭代查询的方式：

- **递归查询**：当一个DNS服务器接收到查询请求后，它会代表客户端完成整个查询流程，直到获取到结果然后再返回给客户端。
- **迭代查询**：当一个DNS服务器接收到查询请求后，如果自己无法解决，它会告诉客户端下一个可以查询的服务器地址，客户端随后向这个服务器发起新的查询请求。

DNS是互联网的基础设施之一，它使得用户无需记忆复杂的IP地址，只需要记住方便阅读和记忆的域名即可。

## 输入 url 到接受到 html 发生了什么

当你在浏览器中输入一个URL并按下回车键后，从请求发送到接收到HTML文档的过程涉及多个步骤。以下是这个过程的概述：

1. **解析URL**：
   浏览器解析URL以确定协议（如HTTP或HTTPS）、服务器的域名和可能的路径。

2. **DNS查询**：
   浏览器向DNS服务器查询域名对应的IP地址。如果这个信息已经在本地DNS缓存中，这一步可以被跳过。

3. **建立TCP连接**：
   浏览器通过网络向服务器的IP地址发起TCP连接。对于HTTPS连接，这一步还包括TLS握手过程，以确保加密通信。

4. **发送HTTP请求**：
   一旦TCP连接建立（对于HTTPS连接，TLS握手也完成），浏览器会构建一个HTTP请求，并通过TCP连接发送给服务器。该请求包含了请求行（如`GET /index.html HTTP/1.1`），请求头部（包含浏览器类型、接受的内容类型等）和可能的请求体。

5. **服务器处理请求**：
   服务器接收到HTTP请求后，会根据请求的路径和方法处理请求。服务器可能会查询数据库、执行后端逻辑、或直接定位到相应的HTML文件。

6. **服务器发送HTTP响应**：
   服务器向浏览器发送一个HTTP响应，该响应包含状态码（如200 OK表示成功），响应头部（包含内容类型、缓存控制等）和响应体（通常是请求的HTML文档）。

7. **浏览器接收HTML**：
   浏览器接收到HTML文档后，会立即开始文档的解析。

8. **解析HTML并构建DOM树**：
   浏览器解析HTML标记，并构建页面的DOM（文档对象模型）树。

9. **CSSOM树构建**：
   浏览器解析同步加载的CSS文件和样式信息，构建CSSOM（CSS对象模型）树。

10. **执行JavaScript**：
    如果HTML引用了JavaScript文件，浏览器会下载并执行它们。JavaScript可以操作DOM和CSSOM树，可能会更改页面的内容和结构。

11. **渲染页面**：
    浏览器将DOM和CSSOM树合并成渲染树，然后根据渲染树来布局页面，并将内容绘制到屏幕上。

12. **加载子资源**：
    HTML文档可能包含了图片、视频、字体等其他资源的链接，浏览器会继续发送HTTP请求来加载这些资源。

13. **用户交互**：
    在页面加载完成后，用户可以开始与页面交互，而浏览器可能会继续在后台处理如JavaScript运行、图片加载等任务。

这个过程可能会因为各种因素而有所不同，例如浏览器缓存、网络条件、服务器配置、是否跨域请求等。但大体上，上述步骤描述了从输入URL到接收到HTML文档的整个过程。

## 浏览器缓存（强缓存，协商缓存），js 文件缓存

浏览器缓存是一种机制，它允许浏览器存储资源文件（如HTML页面、图片、JavaScript文件和CSS样式表）到本地磁盘，以便在后续的浏览中快速加载这些资源，从而减少网络传输、降低延迟并提升用户体验。浏览器缓存可以分为两大类：强缓存和协商缓存。

### 强缓存（Strong Cache）

强缓存不会向服务器发送请求，直接从缓存中读取资源。强缓存是通过HTTP响应头中的两个字段控制的：

- `Expires`：这是HTTP/1.0的字段，表示资源的到期时间，是一个绝对时间点，由服务器指定。如果请求的时间小于`Expires`指定的时间，则直接使用缓存的资源，不会与服务器进行通信。
- `Cache-Control`：这是HTTP/1.1的字段，优先级高于`Expires`。它可以通过多个指令控制缓存，如`max-age`指定资源可以被缓存多久，`no-cache`和`no-store`分别表示不使用强缓存和不缓存任何内容。

### 协商缓存（Negotiated Cache）

当强缓存失效后，浏览器会向服务器发送请求，询问资源是否被修改。协商缓存是通过两对HTTP头实现的：

- `Last-Modified` 和 `If-Modified-Since`：服务器在响应时通过`Last-Modified`头通知浏览器资源最后修改的时间。浏览器下次请求时，通过`If-Modified-Since`头将这个时间发送给服务器。如果服务器上资源的最后修改时间没有变化，服务器会返回304状态码，告诉浏览器可以使用缓存的资源。
- `ETag` 和 `If-None-Match`：`ETag`是资源的唯一标识符，服务器通过`ETag`响应头提供。浏览器在后续请求中通过`If-None-Match`头将`ETag`发送给服务器。如果`ETag`没有变化，服务器返回304状态码，浏览器使用缓存的资源。

### JavaScript 文件缓存

JavaScript文件也遵循上述的缓存机制。当浏览器首次加载一个JavaScript文件时，它会根据HTTP响应头中的缓存控制指令（如`Cache-Control`）来决定是否缓存文件，以及缓存多久。如果设置了强缓存，并且缓存尚未到期，浏览器会直接从缓存加载JS文件，而不会向服务器发起请求。

如果强缓存失效，浏览器会使用协商缓存的机制，通过`If-Modified-Since`或`If-None-Match`头与服务器进行通信，确认文件是否有更新。如果服务器返回304状态码，说明文件未修改，浏览器将继续使用缓存中的文件。

为了确保用户能够获取到最新的JavaScript文件，开发者有时会在文件名或请求的查询字符串中添加版本号或哈希值，这样文件内容的任何变化都会导致URL的变化，从而绕过缓存直接请求新的资源。

缓存策略的选择和配置对于网站性能优化至关重要，它需要根据资源的更新频率、应用的需求等因素来灵活设置。

## 浏览器收到 html 后会如何渲染


浏览器收到HTML文件后，会经历以下步骤来渲染页面：

1. **解析HTML构建DOM树**：
   浏览器开始解析HTML文档，并将标签转换成树状的数据结构，称为文档对象模型（DOM）。DOM树是由DOM元素（如`<div>`、`<p>`等）和属性组成的结构。

2. **解析CSS构建CSSOM树**：
   同时，浏览器解析所有的CSS样式（包括外部CSS文件和页面内的样式）。解析完成后，浏览器构建CSS对象模型（CSSOM）树。CSSOM树反映了所有CSS属性的层叠和继承规则。

3. **合并DOM树和CSSOM树生成渲染树**：
   浏览器将DOM树和CSSOM树合并成一个渲染树（Render Tree）。渲染树只包含需要显示的DOM元素及其样式信息，不可见的元素（如`<head>`标签内的内容或使用`display: none`样式的元素）不会被包含在渲染树中。

4. **布局（Layout/Reflow）**：
   浏览器计算渲染树中每个节点的准确位置和大小，这个过程也被称为布局或回流。布局阶段确定了每个元素在页面上的确切坐标。

5. **绘制（Paint）**：
   完成布局后，浏览器将渲染树上的每个节点转换成屏幕上的实际像素，这个过程称为绘制。绘制包括文本内容、颜色、图像、边框、阴影等。

6. **合成（Compositing）**：
   如果页面中有复杂的效果，如层叠、3D变换或滤镜，浏览器会将页面分割成多个层，然后独立渲染这些层。最后，浏览器会合成这些层并显示在屏幕上。

7. **动态更新**：
   如果HTML、CSS或JavaScript中的任何内容发生变化，浏览器可能会执行上述步骤的一部分或全部，以更新页面。这包括JavaScript操作DOM，引起的回流（重新布局）和重绘。

整个过程是高度优化的，旨在尽可能快地将内容渲染到屏幕上。开发者可以通过优化资源加载顺序、减少DOM操作、使用高效的CSS选择器等方式来提高渲染性能。此外，现代浏览器还支持异步加载资源和延迟执行JavaScript，这可以进一步提高页面的渲染效率。

## 变量提升


在JavaScript中，变量提升（Hoisting）是一个行为，它将变量和函数声明在编译阶段移动到它们各自作用域的顶部。这意味着无论声明在何处进行，都会在代码执行之前被移动到作用域的最上面。需要注意的是，提升只会移动声明，而不会移动赋值。

### 变量提升

对于用`var`关键字声明的变量，提升的行为表现为：

- 变量的声明会被提升到其作用域的顶部。
- 变量的初始化（赋值操作）不会被提升，它会留在原地执行。

例如：

```javascript
console.log(myVar); // 输出：undefined，而不是报错
var myVar = 5;
console.log(myVar); // 输出：5
```

在这个例子中，变量`myVar`的声明（`var myVar;`）被提升到作用域的顶部，但是赋值（`myVar = 5;`）留在原来的位置。因此，在变量`myVar`声明之前就可以访问它，但是值是`undefined`。

对于`let`和`const`声明的变量，虽然技术上也会提升，但它们有一个所谓的“暂时性死区”（Temporal Dead Zone, TDZ），这意味着在声明之前的任何地方尝试访问变量将会导致错误。

```javascript
console.log(myLetVar); // ReferenceError: myLetVar is not defined
let myLetVar = 5;
```

在这个例子中，尽管`myLetVar`的声明被提升，但是在声明之前尝试访问它会导致引用错误。

### 函数提升

函数声明也会被提升，但是函数表达式不会被提升。当提升函数声明时，整个函数的定义都会被提升到作用域的顶部。

```javascript
console.log(myFunc()); // 输出："Hello, world!"

function myFunc() {
  return "Hello, world!";
}
```

在这个例子中，尽管调用`myFunc`函数发生在声明之前，但是函数声明提升使得这段代码可以正常工作。

但是，如果函数是以函数表达式的形式赋值给变量，那么这种提升的行为就不会发生。

```javascript
console.log(myFuncExp()); // TypeError: myFuncExp is not a function

var myFuncExp = function() {
  return "Hello, world!";
};
```

在这个例子中，变量`myFuncExp`的声明被提升了，但是赋值部分没有被提升。因此，尝试调用`myFuncExp`时，它的值是`undefined`，而不是函数，导致类型错误。

理解变量提升是编写无误的JavaScript代码的关键部分，并且是面试中常见的一个问题。通过理解和合理利用提升，可以避免一些难以发现的错误。

## 浏览器如何处理的 css 的 inline 样式和一般样式

浏览器处理CSS样式，无论是内联样式（inline styles）还是外部或内部的一般样式表（external or internal stylesheets），都遵循相同的基本步骤，但优先级（specificity）和加载方式有所不同。

### 加载和解析

1. **外部样式表**：浏览器通过`<link>`标签引入的CSS文件，需要进行网络请求，下载并解析这些文件。下载是异步进行的，以避免阻塞文档的渲染。一旦下载完成，浏览器就会解析CSS并生成CSSOM（CSS Object Model）。

2. **内部样式表**：通过`<style>`标签直接在HTML文档中写入的样式，浏览器在解析HTML时同步解析这些样式，并构建CSSOM。

3. **内联样式**：通过HTML元素的`style`属性直接定义的样式，这些样式是在解析HTML元素时读取和应用的，因此不需要额外的下载和解析过程。

### 应用样式和计算优先级

浏览器在构建CSSOM后，会将其与DOM（Document Object Model）合并，创建渲染树。在这个过程中，浏览器会根据以下规则来决定如何应用样式和计算优先级：

1. **重要性（Importance）**：`!important`声明的样式比普通声明的样式有更高的优先级。

2. **优先级（Specificity）**：如果没有`!important`声明，浏览器会计算选择器的特异性，即选择器的详细程度。内联样式具有最高的特异性，然后是ID选择器，然后是类选择器和伪类选择器，最后是元素选择器和伪元素选择器。

3. **源代码顺序（Source Order）**：如果重要性和特异性相同，后出现在源代码中的样式会覆盖先出现的样式。

内联样式由于其特异性高（每个内联样式直接应用于一个元素），通常会覆盖外部和内部样式表中的任何样式（除非外部或内部样式使用了`!important`）。然而，使用内联样式可能会导致维护困难，因为样式和内容混在一起，而且违反了CSS的核心原则——内容与表现分离。

最终，浏览器会根据计算出的优先级和重要性，为每个元素应用最终的样式，并进行布局和绘制。这个过程可能会因为JavaScript操作（如修改元素的`style`属性或操作类名）而触发重排（reflow）和重绘（repaint）。


## 如何理解 `<script />` 中的 defer async 两个属性

在HTML中，`<script>`标签可以包含两个与加载和执行JavaScript脚本相关的重要属性：`async`和`defer`。这两个属性告诉浏览器如何处理标签中指定的脚本文件。它们只对带有`src`属性的外部脚本文件有效，即那些不是直接嵌入到HTML中的脚本。

### async 属性

当你给`<script>`标签添加`async`属性时，你告诉浏览器它可以在脚本文件被下载的同时继续解析HTML文档。这意味着：

- 脚本文件会异步加载，不会阻塞HTML文档的解析。
- 一旦脚本文件下载完毕，浏览器会中断HTML解析来执行脚本。
- 多个带有`async`属性的脚本可能不会按照它们在文档中出现的顺序执行。

`async`属性适用于那些不依赖于其他脚本或DOM的独立模块，因为它们的加载和执行不会被其他脚本或HTML解析的状态所影响。

### defer 属性

`defer`属性也会让浏览器异步下载脚本文件，但有一个关键的不同：

- 脚本文件会异步加载，但不会中断文档的解析。
- 不同于`async`，`defer`脚本会在整个文档解析完毕后、`DOMContentLoaded`事件触发前按照它们在文档中出现的顺序执行。
- 这意味着带有`defer`属性的脚本总是在DOM构建完毕后执行，这对于依赖于DOM的脚本来说是非常有用的。

`defer`属性通常用于那些需要等待整个页面加载和解析完毕后才运行的脚本，如依赖于DOM存在的脚本。

### 没有 async 或 defer

如果`<script>`标签既没有`async`也没有`defer`属性：

- 浏览器会立即停止解析HTML文档，同步下载并执行脚本文件。
- 这会导致页面的加载和渲染被阻塞，直到脚本执行完毕。

### 总结

- 使用`async`时，脚本会在它们下载完成后尽快执行，可能会在文档解析完成之前或之后。
- 使用`defer`时，脚本会在整个文档解析完成后、在`DOMContentLoaded`事件之前按顺序执行。
- 如果没有使用`async`或`defer`，脚本会立即下载并执行，阻塞文档的解析。

在现代网页开发中，推荐使用`defer`，因为它能保证脚本的执行顺序，并且不会阻塞文档的解析。这有助于提高页面的加载性能。

## 如何触发 BFC

BFC（Block Formatting Context）是Web页面的可视CSS渲染的一部分，它是页面中的一个独立的渲染区域，让处于BFC内部的元素与外部的元素相互隔离，确保内部元素的布局不会影响到外面的元素。

触发BFC的条件有：

1. **根元素**（`<html>`）本身就是一个BFC。

2. **浮动元素**：元素的`float`不是`none`。

3. **绝对定位元素**：元素的`position`是`absolute`或`fixed`。

4. **内联块**：元素的`display`是`inline-block`。

5. **表格单元格**：元素的`display`是`table-cell`，通常是`<td>`和`<th>`元素。

6. **表格标题**：元素的`display`是`table-caption`，通常是`<caption>`元素。

7. **匿名表格单元格元素**：元素的`display`是`table`、`table-row`、`table-row-group`、`table-header-group`、`table-footer-group`（基本上，任何`table`相关的display值）。

8. **块级元素**：元素的`display`是`flow-root`。

9. **弹性元素**：将元素的`display`属性设置为`flex`或`inline-flex`会为其内容创建新的BFC。

10. **网格元素**：将元素的`display`属性设置为`grid`或`inline-grid`会为其内容创建新的BFC。

11. **多列容器**：元素的`column-count`或`column-width`不是`auto`，包括使用`column-count`属性实现的多列布局。

12. **overflow**：元素的`overflow`不是`visible`。

在实际应用中，最常用的触发BFC的方法是通过设置元素的`overflow`属性为`hidden`、`scroll`或`auto`，以及使用`display: flow-root`来创建新的BFC。这些方法通常用于解决边距折叠（margin collapsing）问题，清除浮动（clearfix），以及防止文字环绕浮动元素等布局问题。

## 两种盒模型是什么？


在CSS中，有两种基本的盒模型：标准盒模型（也称为内容盒模型）和替代盒模型（也称为边框盒模型）。

### 标准盒模型（Content Box Model）

在标准盒模型中，如果你为一个元素设置了宽度和高度，这些值就是内容区域（content area）的宽度和高度。内容之外的内边距（padding）、边框（border）和外边距（margin）是额外计算的，不包括在定义的宽度和高度之内。

例如，如果你有一个元素：

```css
.box {
  width: 300px;
  height: 200px;
  padding: 20px;
  border: 5px solid black;
  margin: 10px;
}
```

实际的总宽度将会是：300px（宽度） + 40px（左右内边距） + 10px（左右边框） = 350px。  
实际的总高度将会是：200px（高度） + 40px（上下内边距） + 10px（上下边框） = 250px。

### 替代盒模型（Border Box Model）

在替代盒模型中，当你为一个元素设置宽度和高度时，这些值实际上包括了内容、内边距和边框。外边距仍然是额外计算的。

这意味着如果你使用相同的CSS声明：

```css
.box {
  box-sizing: border-box;
  width: 300px;
  height: 200px;
  padding: 20px;
  border: 5px solid black;
  margin: 10px;
}
```

实际的总宽度和高度将保持为300px和200px，内边距和边框会被包含在这个尺寸内。

### 切换盒模型

你可以通过CSS的`box-sizing`属性来切换这两种盒模型。默认情况下，所有元素都是`content-box`，如果你想使用边框盒模型，你需要设置`box-sizing: border-box;`。

```css
.box {
  box-sizing: border-box;
}
```

现代网页设计中，`border-box`通常更受欢迎，因为它简化了布局的计算，尤其是当你在设计响应式布局时。通过设置`* { box-sizing: border-box; }`，可以让所有元素都使用这种模型，这样做可以让布局的计算更直观和一致。

## 隐藏元素的方式有什么？区别是什么？隐藏了元素，点击事件是否能触发？


隐藏HTML元素的方式主要有以下几种，每种方式的特点和对点击事件的影响也不同：

### 1. `display: none;`
将元素的`display`属性设置为`none`会从文档布局中完全移除该元素，就像它从未存在过一样。这意味着它不会占据任何空间，也不会影响到布局中的其他元素。

- **点击事件：** 不能触发，因为元素实际上已经从文档流中移除了。

### 2. `visibility: hidden;`
将元素的`visibility`属性设置为`hidden`会使元素不可见，但它仍然占据原来的空间，并且保持其在文档流中的位置。

- **点击事件：** 通常不能触发，因为元素虽然在文档流中，但是不可见，也不响应用户交互。

### 3. `opacity: 0;`
将元素的`opacity`属性设置为`0`会使元素完全透明，但它仍然占据空间并且保持其在文档流中的位置。

- **点击事件：** 能触发，因为元素仍然存在于文档流中，只是看起来透明了。

### 4. `position: absolute;` 或 `position: fixed;` 加上偏移
通过将元素定位为`absolute`或`fixed`，并将其移出可视区域，例如设置`top: -9999px;`，可以使元素不在屏幕上显示。

- **点击事件：** 不能触发，因为元素不在可视区域内。

### 5. `overflow: hidden;` 加上限制宽高
如果一个元素的子元素超出了设定的宽度和高度，可以通过设置`overflow: hidden;`来隐藏溢出的部分。

- **点击事件：** 对于溢出隐藏的部分不能触发，因为它们不在可视区域内。

### 6. 使用HTML5的`hidden`属性
HTML5引入了一个新的全局属性`hidden`，用于隐藏元素。

- **点击事件：** 不能触发，因为这个属性基本上是将`display`设置为`none`。

### 7. `clip-path: circle(0);` 或 `clip: rect(0, 0, 0, 0);`
通过`clip-path`或`clip`属性，你可以创建一个剪裁路径，使得元素的内容在这个路径之外的部分不会被显示。

- **点击事件：** 通常不能触发，因为元素的可视部分不存在。

### 8. `z-index`负值
如果元素是定位元素（即`position`属性不是`static`），可以通过设置一个负的`z-index`值将其层叠顺序放到其他内容之下。

- **点击事件：** 可能能触发，如果没有其他元素覆盖在该元素上方。

在实际应用中，选择哪种方式取决于你的需求。如果你想要元素从布局中完全消失并且不占据空间，通常使用`display: none;`。如果你想保持布局结构不变，但只是简单地隐藏元素，可以使用`visibility: hidden;`。当你需要元素透明但仍然响应事件时，可以使用`opacity: 0;`。其他方法根据特定的上下文和需求来选择使用。

## js 判断类型，typeof 和 instanceof 的区别，有什么其他方法判断类型

在JavaScript中，判断变量类型通常会用到`typeof`和`instanceof`两个操作符，它们的使用场景和判断依据有所不同。

### `typeof`
`typeof`是一个一元操作符，用来返回一个变量的基本类型。它的语法很简单：

```javascript
typeof variable;
```

`typeof`对于基本数据类型通常返回准确的类型字符串：

- `"undefined"` - 如果变量是`undefined`
- `"boolean"` - 如果变量是布尔值
- `"number"` - 如果变量是数字
- `"string"` - 如果变量是字符串
- `"symbol"` - 如果变量是ES6引入的符号类型
- `"bigint"` - 如果变量是大整数类型
- `"function"` - 如果变量是函数

对于对象类型，`typeof`大多数情况下会返回`"object"`，但这不是很有帮助，因为数组、null、对象都会返回`"object"`。因此，`typeof`在判断非基本类型时通常不是很有用。

### `instanceof`
`instanceof`是一个二元操作符，用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性。

```javascript
object instanceof Constructor;
```

如果对象继承自构造函数的原型，或者说构造函数的`prototype`属性在对象的原型链上，`instanceof`就会返回`true`。

`instanceof`对于自定义对象类型检测很有用，例如检测某个对象是否是`Date`的实例，或者是否是某个类的实例。但是对于原始类型，`instanceof`就不适用了，因为原始类型不是对象。

### 其他方法判断类型
除了`typeof`和`instanceof`，还有其他几种方法可以用来判断JavaScript中的数据类型：

1. `Object.prototype.toString.call()`
   这个方法可以返回一个表示对象类型的字符串，例如：

   ```javascript
   Object.prototype.toString.call([]); // "[object Array]"
   Object.prototype.toString.call({}); // "[object Object]"
   Object.prototype.toString.call(new Date()); // "[object Date]"
   ```

   这种方法可以准确判断数组、对象、函数等多种类型。

2. `Array.isArray()`
   ES5引入了这个方法来判断一个变量是否是数组，因为使用`typeof`无法区分数组和普通对象。

   ```javascript
   Array.isArray([]); // true
   Array.isArray({}); // false
   ```

3. `constructor`属性
   每个对象都有一个`constructor`属性，指向创建该对象的构造函数。这可以用来判断对象的类型：

   ```javascript
   ({}).constructor === Object; // true
   ([]).constructor === Array; // true
   ```

4. 使用`instanceof`检测原始类型的包装对象
   如果原始类型被转换成了它们的包装对象（例如，通过`new String("text")`），`instanceof`可以被用来检测它们：

   ```javascript
   var strObject = new String("text");
   strObject instanceof String; // true
   ```

在使用这些方法时，需要注意JavaScript中的一些特殊情况，例如`null`和`NaN`。`null`是一个对象类型（这实际上是JavaScript的一个错误），`NaN`是一个特殊的`Number`类型。对于这些特殊值，你可能需要做特别的判断逻辑。


## 事件循环是什么？

事件循环（Event Loop）是JavaScript的一种运行机制，它允许JavaScript引擎在执行代码时处理异步事件。由于JavaScript是单线程的，事件循环机制能够协调那些需要长时间等待的操作（如：I/O、异步请求、定时事件等），而不会阻塞主线程。

### 工作原理

事件循环的工作原理可以分为几个关键部分：

1. **调用栈（Call Stack）**:
   调用栈是一个数据结构，用于记录在程序中的哪个部分被执行。当一个函数被调用时，它会被添加到调用栈的顶部。当函数返回时，它会从调用栈顶部被移除。

2. **任务队列（Task Queue）**:
   当异步事件发生时，例如一个HTTP请求完成或一个定时器到期，相应的回调函数会被添加到任务队列中。如果调用栈为空，事件循环会从任务队列中取出任务到调用栈中执行。

3. **微任务队列（Microtask Queue）**:
   微任务（如Promise的回调）会被添加到微任务队列中。微任务队列与任务队列类似，但是它的优先级更高，事件循环会在每次执行完调用栈中的任务后，立即处理所有微任务队列中的事件。

4. **渲染更新（Rendering）**:
   浏览器的渲染过程通常与事件循环同步，浏览器会在特定的时机进行页面的重绘和重排。这通常发生在事件循环的每一轮循环中，处理完微任务队列之后。

### 事件循环的步骤

事件循环的每一轮循环通常包括以下步骤：

1. 执行调用栈中的同步任务。
2. 调用栈为空后，执行所有微任务（例如，Promise的`.then()`或`.catch()`回调）。
3. 如果有必要，更新渲染。
4. 开始下一轮循环，从任务队列中取出一个任务执行。
5. 重复这个过程。

### 事件模型的相关问题

1. **解释一下 JavaScript 的事件循环模型。JavaScript 是如何处理异步任务的？**

    JavaScript 的事件循环模型允许它在单线程环境中处理异步操作。主要概念包括调用栈、事件队列、微任务和宏任务。当一个任务（函数）开始执行，它被添加到调用栈中。如果这个任务产生了异步操作（如 `setTimeout`），则其回调函数被添加到事件队列中。当调用栈为空时，事件队列中的任务（宏任务）被添加到调用栈中执行。微任务（如 `Promise` 的回调）在每个事件循环迭代的结束时执行，优先级高于宏任务。

2. **解释一下 JavaScript 中的微任务和宏任务，它们的区别是什么？**

    宏任务和微任务都是异步任务，但它们的执行时间不同。宏任务包括脚本整体代码、`setTimeout`、`setInterval`、`setImmediate`（Node.js）、`I/O`、`UI rendering` 等，它们在事件队列中等待执行。微任务包括 `Promise`、`process.nextTick`（Node.js）、`MutationObserver` 等，它们在每个事件循环迭代的结束时执行，优先级高于宏任务。

3. **以下代码的输出是什么？为什么？**
    ```javascript
    console.log('start');
    setTimeout(() => console.log('setTimeout'), 0);
    Promise.resolve().then(() => console.log('promise'));
    console.log('end');
    ```
   输出会是：
    ```
    start
    end
    promise
    setTimeout
    ```
    首先，同步代码 'start' 和 'end' 执行。然后，尽管 `setTimeout` 的延迟时间为 0，但它是一个宏任务，所以被添加到事件队列中等待执行。`Promise.resolve().then` 是一个微任务，它在当前事件循环结束时执行，因此 'promise' 会在 'setTimeout' 之前打印出来。

4. **你能解释一下 `Promise`，`setTimeout`，`setImmediate`（Node.js）的执行顺序吗？**

    在 Node.js 环境中，`Promise`、`setTimeout` 和 `setImmediate` 的执行顺序可能会有所不同，具体取决于它们的调用环境。通常，`Promise` 的优先级最高，因为它是一个微任务，会在当前事件循环结束时执行。`setTimeout` 和 `setImmediate` 都是宏任务，但在某些情况下（例如在 I/O 回调中），`setImmediate` 可能会先于 `setTimeout` 执行。

5. **解释一下 `process.nextTick` 和 `setImmediate` 在 Node.js 中的区别。**

    在 Node.js 中，`process.nextTick` 和 `setImmediate` 都用于安排异步操作。`process.nextTick` 将回调函数添加到下一个微任务队列，这意味着它会在任何 I/O 或其他的宏任务（包括 `setTimeout` 和 `setImmediate`）之前执行。而 `setImmediate` 则是将回调函数添加到宏任务队列，它会在下一个事件循环迭代开始时执行。

6. **在浏览器环境下，`requestAnimationFrame` 是如何工作的？它与 `setTimeout` 和 `setInterval` 有什么区别？**

    `requestAnimationFrame` 是浏览器提供的 API，用于在下一次重绘之前调用指定的函数，这使得动画更加流畅。它与 `setTimeout` 和 `setInterval` 的主要区别在于，`requestAnimationFrame` 会尽可能地与浏览器的重绘同步，从而提供更流畅的视觉效果。而 `setTimeout` 和 `setInterval` 则无法保证回调函数的执行与浏览器的重绘同步。

### 重要性

事件循环对于JavaScript来说至关重要，因为它允许我们利用异步编程，这对于避免长时间运行的任务阻塞用户界面非常重要。例如，在Web应用程序中，如果没有事件循环，每次发起网络请求或执行耗时操作时，整个网页都会冻结，直到操作完成。

理解事件循环还有助于开发者编写出更高效、响应性更好的应用程序，并避免常见的问题，如回调地狱和竞态条件。

## 闭包概念是什么？请手动实现curry

### 闭包（Closure）

闭包是JavaScript中的一个重要概念。在JavaScript中，闭包发生在一个函数内部创建另一个函数时。内部函数会“记住”它被创建时的环境，这意味着它可以访问外部函数的变量，即使外部函数已经执行完毕。

闭包的特点：

- **访问外部函数作用域中的变量**：内部函数可以访问定义它的外部函数中的变量，即使外部函数已经返回。
- **保护变量的私有性**：闭包可以创建私有变量，防止它们被外部访问，实现封装。
- **持久化变量**：通常，当函数执行完毕后，其作用域中的局部变量会被销毁。但闭包中的变量可以保持活动状态，供内部函数在后续任何时间访问。

### Currying（柯里化）

柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数的技术。柯里化后的函数接受一个参数并返回接受下一个参数的函数，直到接收完所有参数，最终返回结果。

柯里化的目的是：

- **参数复用**：固定一些参数，生成一个新的函数，便于多次重复调用。
- **提前确认**：执行多参数的函数时，不必一次性传入所有参数，可以逐步传入。
- **延迟运行**：直到传入了所有参数，函数才真正执行。

### 手动实现Curry函数

下面是一个简单的柯里化函数实现，它可以逐步接收参数，并在接收到足够参数后执行原函数：

```javascript
function curry(fn, ...args) {
  // 判断已经接收的参数数量是否等于原函数定义的参数数量
  if (args.length >= fn.length) {
    // 如果足够，则直接执行函数
    return fn(...args);
  } else {
    // 如果不够，返回一个新的函数，继续接收参数
    return function(...newArgs) {
      // 递归调用curry函数，并拼接新旧参数
      return curry(fn, ...args.concat(newArgs));
    };
  }
}

// 示例使用
function sum(a, b, c) {
  return a + b + c;
}

const curriedSum = curry(sum);

console.log(curriedSum(1)(2)(3)); // 输出6
console.log(curriedSum(1, 2)(3)); // 输出6
console.log(curriedSum(1, 2, 3)); // 输出6
```

这个`curry`函数检查已经接收的参数数量是否足够，如果足够，就直接执行原函数；如果不足，就返回一个新的函数，等待接收更多的参数。这个过程会递归进行，直到收集齐所有需要的参数。


## 怎么设计前端上报的sdk？有什么优化点可以做？


设计一个前端上报的SDK（Software Development Kit）通常涉及到以下几个方面：

1. **功能需求**：首先要明确上报的需求，比如错误监控、性能监控、用户行为追踪等。

2. **数据采集**：根据需求采集相应的数据。例如，对于错误监控，需要捕获JavaScript错误、资源加载错误等；对于性能监控，需要采集白屏时间、首屏时间、用户可交互时间等。

3. **数据格式**：定义统一的数据格式，方便后端存储和处理。

4. **上报策略**：设计合理的数据上报策略，比如实时上报、批量上报、延迟上报等。需要考虑网络状况、用户体验和服务器负载等因素。

5. **数据传输**：选择合适的传输方式，如通过Image对象（利用GET请求的方式）、Ajax（XMLHttpRequest或Fetch API）、Beacon API等。

6. **异常处理**：确保SDK的稳定性，不影响宿主页面的正常功能。

7. **安全性**：保证数据传输的安全性，防止数据被截取或篡改。

8. **兼容性**：确保SDK能够在不同的浏览器和设备上正常工作。

9. **易用性**：提供简单明了的API，方便开发者集成和使用。

10. **配置项**：允许开发者通过配置项来定制SDK的行为，如上报的服务器地址、上报频率等。

优化点主要包括：

1. **性能优化**：
   - **减少影响**：确保SDK代码运行效率高，不影响宿主页面性能。
   - **异步加载**：通过异步加载的方式引入SDK，避免阻塞页面渲染。
   - **代码压缩**：减小SDK文件大小，通过代码压缩和优化来减少加载时间。

2. **上报优化**：
   - **节流和防抖**：对于频繁发生的事件，可以使用节流和防抖技术减少上报次数。
   - **本地缓存**：在网络不佳的情况下，可以先将数据缓存到本地，待网络恢复时再统一上报。
   - **数据压缩**：对上报的数据进行压缩，减少传输数据量。

3. **容错性**：
   - **重试机制**：上报失败后，可以设计重试机制，在合适的时机重新上报。
   - **异常捕获**：确保SDK内部不会因为异常而影响到外部页面。

4. **用户体验**：
   - **无痕上报**：尽量不影响用户的正常使用，比如通过Beacon API在页面卸载时上报数据，减少对用户操作的干扰。

5. **安全性和隐私**：
   - **数据脱敏**：在上报数据之前，对敏感信息进行脱敏处理。
   - **遵循政策**：确保符合各地区的数据保护法规，如GDPR。

6. **可维护性和可扩展性**：
   - **模块化**：将SDK设计为模块化，方便维护和扩展。
   - **文档和示例**：提供完善的文档和示例代码，便于开发者理解和集成。

设计前端上报的SDK是一个需要综合考虑多方面因素的任务，需要不断地根据实际应用场景和数据来优化和调整。


## 怎么样判断一个请求是成功还是失败？


在前端开发中，判断一个请求成功或失败通常依赖于HTTP响应状态码、网络错误以及业务逻辑中定义的成功与失败。以下是一些常见的判断方法：

### 1. HTTP状态码
HTTP状态码是判断请求成功与否的一个重要依据：

- `2xx` 状态码表示成功，例如 `200 OK` 表示请求成功。
- `3xx` 状态码表示重定向，客户端需要进一步的操作来完成请求。
- `4xx` 状态码表示客户端错误，例如 `404 Not Found` 或 `400 Bad Request`。
- `5xx` 状态码表示服务器错误，例如 `500 Internal Server Error`。

### 2. 网络错误
如果请求没有到达服务器，比如因为网络断开、DNS查找失败等，这通常会通过JavaScript的错误回调来通知，例如在使用 `fetch` API时，如果遇到网络故障，`fetch` 会返回一个reject的Promise。

### 3. 业务逻辑错误
有时候即使HTTP状态码表示成功，也可能因为业务逻辑的原因，请求实际上是失败的。例如，后端可能会在响应体中返回特定的错误码或者消息来表示业务逻辑上的错误。

```javascript
fetch('some-api-endpoint')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    // 判断业务逻辑上是否成功
    if (data.code !== 'SUCCESS') {
      throw new Error(data.message || 'Business logic error');
    }
    // 处理业务逻辑上的成功情况
  })
  .catch(error => {
    // 处理请求失败的情况
  });
```

在实际的业务中，你需要根据具体的业务需求和后端API的设计来决定如何判断请求是否成功。通常来说，你需要结合HTTP状态码和后端返回的业务数据共同判断。

## 大文件上传的注意点有什么？

大文件上传是一个复杂的过程，需要考虑网络稳定性、用户体验和服务器负载等多个因素。以下是一些在设计和实现大文件上传功能时需要注意的关键点：

### 1. 分片上传
将大文件分割成多个小块（分片），逐个上传。这样做的好处是：

- **断点续传**：如果上传过程中某个分片失败，可以重新上传该分片而不是整个文件。
- **并行上传**：可以同时上传多个分片，提高上传效率。
- **进度控制**：可以更精确地显示上传进度，提升用户体验。

### 2. 断点续传
支持断点续传不仅可以提升用户体验，还可以减少因网络问题导致的重复上传，减轻服务器压力。实现断点续传通常需要：

- 在客户端记录已上传的分片信息。
- 在服务器端也要有机制记录哪些分片已经上传完成。

### 3. 网络环境适应性
根据用户的网络环境（如带宽大小）动态调整分片大小和上传速度，以达到最优的上传效率。

### 4. 安全性
- **验证**：确保上传的文件块在服务器端进行完整性校验，防止数据丢失或被篡改。
- **权限**：验证用户的上传权限，防止未授权的文件上传。
- **加密**：在传输过程中使用HTTPS等加密手段，保障数据传输的安全。

### 5. 用户体验
- **进度反馈**：实时显示上传进度，包括速度、剩余时间等信息。
- **错误处理**：对于上传失败的情况，提供重试或恢复上传的选项。
- **后台上传**：允许用户在上传过程中继续浏览或进行其他操作。

### 6. 服务器端处理
- **并发控制**：服务器端要有并发处理机制，以应对多个用户同时上传大文件的情况。
- **资源清理**：对于未完成的上传，需要有机制定期清理服务器端的临时文件。

### 7. 兼容性和限制
- **浏览器兼容性**：确保上传功能在所有支持的浏览器上都能正常工作。
- **文件大小限制**：根据服务器能力和业务需求设定单个文件和单次上传的总大小限制。

### 8. 测试
- **压力测试**：确保服务器能够处理高并发的上传请求。
- **断网测试**：模拟网络不稳定情况下的上传行为，确保上传过程的健壮性。

### 9. 反馈机制
- **日志记录**：记录上传过程中的关键信息，便于问题的追踪和调试。
- **监控**：实时监控上传服务的状态，及时发现并处理问题。

### 10. 优化
- **服务端优化**：使用负载均衡、CDN等技术提高文件传输速度和系统的稳定性。
- **客户端优化**：合理安排上传队列，避免在客户端造成过多的并发请求。

### 11. 法律和隐私
- **遵守法律**：确保上传内容符合相关法律法规，不侵犯版权或传播违禁内容。
- **隐私保护**：对用户上传的敏感信息进行保护，防止泄露。

通过考虑这些关键点，你可以设计出一个既可靠又高效的大文件上传系统。

## webWorker,shared Worker,serviceWorker是什么，区别是什么？

Web Workers、Shared Workers和Service Workers是Web平台提供的不同类型的workers，它们使得在浏览器中执行JavaScript时可以在后台线程中进行，而不会阻塞主线程。下面是它们的定义和区别：

### Web Worker
Web Worker允许开发者运行一个脚本操作在与主线程分离的后台线程中。这意味着可以执行耗时的计算而不冻结用户界面。每个Web Worker有其自己的全局上下文，因此不能直接访问DOM。与主线程的通信是通过消息传递机制实现的。

### Shared Worker
Shared Worker是Web Worker的一个变体，它可以被多个脚本（即使是不同浏览器窗口、iframe或者标签页）共享。Shared Worker可以让多个进程之间进行通信和数据共享。与Web Worker类似，它也不能直接访问DOM，并且与主线程之间的通信是通过消息传递机制实现的。

### Service Worker
Service Worker是一种在Web浏览器后台独立于网页运行的脚本，它可以用来拦截和处理网络请求，包括可编程的响应缓存。Service Workers的设计意图主要是允许内容的离线使用、推送通知和背景同步等功能。Service Worker在不同的生命周期事件中运行，如安装、激活、获取和推送事件。

### 区别
- **生命周期**：
  - **Web Worker**：由创建它的脚本控制，当页面关闭时也会随之终止。
  - **Shared Worker**：独立于创建它的脚本，可以跨多个脚本和页面共享，生命周期比Web Worker长。
  - **Service Worker**：有独特的生命周期，安装后可以控制多个页面，即使完全关闭了网页也可以在后台运行。

- **作用范围**：
  - **Web Worker**：局限于单个页面。
  - **Shared Worker**：可以被同源的多个页面共享。
  - **Service Worker**：作用于注册了Service Worker的整个域名下的页面。

- **功能**：
  - **Web Worker**：适合于执行那些不需要修改DOM，但可能会执行较长时间的算法计算的任务。
  - **Shared Worker**：可以用于不同页面或标签页之间的数据共享和通信。
  - **Service Worker**：主要用于离线内容的缓存、推送通知和网络请求的背景处理。

- **通信方式**：
  - **Web Worker**和**Shared Worker**：通过`postMessage`方法和`onmessage`事件处理器进行通信。
  - **Service Worker**：通过监听和响应事件来处理服务逻辑，如`fetch`、`push`、`sync`等。

- **访问能力**：
  - 所有类型的workers都不能直接访问DOM。
  - Service Worker有能力拦截和处理通过浏览器发出的网络请求。

理解这些workers的主要区别可以帮助开发者根据具体需求选择合适的技术来构建网页和应用。

## webWorker是否支持跨域加载脚本？

Web Workers 支持跨域加载脚本，但是这需要脚本服务器支持跨源资源共享 (CORS)。当你尝试从一个不同的域名加载一个脚本到 Web Worker 时，请求将受到同源策略的限制，除非响应头中包含适当的 CORS 头信息。

为了跨域加载脚本，服务器必须在响应中包含 `Access-Control-Allow-Origin` 头，并且该头的值要么是请求来自的域，要么是一个 `*`，表示接受任何域的请求。

例如，如果你的页面是从 `https://example.com` 加载的，并且你想从 `https://cdn.example.com` 加载一个 Web Worker 脚本，`https://cdn.example.com` 服务器需要在响应中包含如下头信息：

```
Access-Control-Allow-Origin: https://example.com
```

或者，如果服务器愿意接受来自任何源的请求：

```
Access-Control-Allow-Origin: *
```

如果没有适当的 CORS 头，浏览器将阻止脚本的加载，并且在控制台中显示一个跨源错误。

要创建一个跨源的 Web Worker，你可以这样做：

```javascript
var worker = new Worker('https://cdn.example.com/worker.js');
```

只要 `https://cdn.example.com/worker.js` 响应了适当的 CORS 头，这段代码就可以正常工作。如果没有，浏览器会报错并阻止脚本的执行。

总之，跨域加载 Web Worker 脚本是可能的，但需要服务器配置正确的 CORS 响应头。

## tcp是双工的么，udp是吗？

TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）是互联网上两个主要的传输层协议。它们的特性和用途有所不同：

### TCP是双工的吗？
是的，TCP是全双工的通信协议。这意味着通信的双方（客户端和服务器）都可以同时发送和接收数据。在一个TCP连接中，数据可以在两个方向上流动，而且每一方都可以同时进行发送和接收操作。

TCP是一个面向连接的协议，它提供可靠的、有序的和基于字节流的传输服务。在数据传输开始之前，TCP会在两个端点之间建立一个连接，并在数据传输结束后关闭连接。TCP还提供拥塞控制、流量控制和错误检测与修正的机制。

### UDP是双工的吗？
UDP本身是一个无连接的协议，它允许数据包在没有事先建立连接的情况下发送。每个UDP数据包都是独立传输的，而且发送者和接收者之间没有明确的连接状态。

从理论上讲，UDP支持全双工通信，因为它允许数据在两个方向上独立传输。发送方可以发送数据包，而接收方也可以回复数据包，它们可以同时进行。但是，UDP不保证数据包的顺序、可靠性或数据完整性。如果需要这些特性，应用层必须自己实现相关的机制。

总结来说，TCP是一个可靠的、面向连接的全双工通信协议，而UDP是一个不可靠的、无连接的协议，它允许数据包在两个方向上独立传输，从这个角度看，它也可以被认为是支持全双工的。但在实际应用中，由于UDP不管理连接状态，所以通常不会特别强调它是全双工的。

## 数字签证中有什么内容以及作用？

数字签名是一种加密技术，用于验证数据的完整性和来源。在数字通信和数据交换中，数字签名扮演着至关重要的角色。它们通常包含以下内容和作用：

### 内容

1. **签名者信息**：数字签名包含了签名者的身份信息，这样接收者可以知道是谁发送了数据。
2. **公钥**：签名通常与签名者的公钥一起提供，用于验证签名的真实性。公钥是与签名者的私钥配对的一部分，它可以公开分享。
3. **散列值**：签名过程包括对原始数据使用散列函数创建一个唯一的散列（或摘要）。散列值随后被私钥加密，形成数字签名。
4. **时间戳**：数字签名可能包含时间戳，表明签名是在特定时间进行的。这有助于防止重放攻击和证明数据在特定时间点的状态。

### 作用

1. **验证身份**：数字签名证明了消息或文档是由持有相应私钥的人签名的，这有助于防止身份伪造。
2. **确保数据完整性**：任何对原始数据的更改，即使是微小的，都会在验证签名时被检测到。因此，数字签名确保数据自签名以来未被更改。
3. **防止否认**：数字签名提供不可否认性，意味着签名者不能否认他们签名的行为，因为只有他们的私钥才能产生相关的签名。
4. **安全通信**：在网络通信中，数字签名提供了一种安全的方式来交换信息，确保传输的数据是可信的。

数字签名通常与其他加密技术（如SSL/TLS证书）一起使用，以提供安全的在线交易和通信。例如，在电子商务、电子邮件、软件分发和其他需要高安全性的场景中，数字签名是不可或缺的。

## canvas导出图片的原理是什么？

`<canvas>` 是 HTML5 中的一个元素，它可以用来绘制图形和图像。当你想要从 `<canvas>` 元素导出图像时，通常会使用 JavaScript 来进行操作。导出 `<canvas>` 中的内容为图像的基本原理如下：

1. **绘制内容**：首先，你需要在 `<canvas>` 元素上使用 JavaScript（通常是通过 Canvas API）来绘制你想要的内容。这可以包括图形、文本、已加载的图像等。

2. **转换为数据URL**：一旦你在 `<canvas>` 上绘制了内容，你可以使用 `toDataURL()` 方法将画布上的内容转换为一个数据URL。这个数据URL是一个包含了图像数据的Base64编码的字符串，它可以直接作为图像源使用。

   ```javascript
   var dataURL = canvas.toDataURL("image/png");
   ```

   上面的代码将会创建一个代表 `<canvas>` 上内容的PNG图像的数据URL。

3. **生成图像文件**：你可以将这个数据URL设置为一个图像的 `src` 属性，或者通过创建一个 `a` 元素并将 `href` 属性设置为数据URL，并给定一个 `download` 属性，来允许用户将其作为文件下载。

   ```javascript
   var downloadLink = document.createElement('a');
   downloadLink.href = dataURL;
   downloadLink.download = 'canvas_image.png';
   document.body.appendChild(downloadLink);
   downloadLink.click();
   document.body.removeChild(downloadLink);
   ```

   上面的代码片段创建了一个下载链接，用户点击后可以将 `<canvas>` 的内容作为PNG图像下载到本地。

4. **处理跨域限制**：如果你在 `<canvas>` 中绘制了跨域的图像资源，那么在导出图像数据时可能会遇到安全限制。为了解决这个问题，图像资源需要在服务器上设置适当的CORS（跨源资源共享）头，而且在绘制到 `<canvas>` 之前，需要在图像对象上设置 `crossOrigin` 属性。

5. **兼容性和性能**：大部分现代浏览器都支持 `toDataURL()` 方法，但是要注意，生成大型图像的数据URL可能会消耗较多的内存，并且在某些情况下可能会有性能问题。

这就是 `<canvas>` 元素导出图像的基本原理。在实际应用中，可能还需要处理各种边界情况和浏览器兼容性问题。

## canvas的渲染原理是什么？和DOM渲染的区别？

`<canvas>` 的渲染原理和 DOM 的渲染原理有一些关键的区别。以下是各自的渲染原理和它们之间的差异：

### canvas渲染原理：

1. **像素操作**：`<canvas>` 是一个位图画布，它允许开发者通过 JavaScript 和 Canvas API 在像素级别上操作图像。当你在 `<canvas>` 上绘制图形时，实际上是在画布的位图上修改像素。

2. **立即模式**：`<canvas>` 使用所谓的“立即模式”（Immediate Mode）渲染，这意味着一旦你发出绘制命令，它们就会立即应用到画布上。没有保留绘制命令的结构或对象表示，一旦绘制，之前的状态就不再存在。

3. **无DOM结构**：`<canvas>` 元素在文档中只是一个容器，它本身不包含任何子节点或是复杂的对象结构。所有的绘制都是通过脚本完成的，绘制的内容并不会成为文档结构的一部分。

4. **性能**：由于 `<canvas>` 直接在像素级别操作，且不涉及 DOM 操作，因此对于大量、快速的图形渲染来说，它可能比 DOM 更高效。

### DOM渲染原理：

1. **结构化文档**：DOM（文档对象模型）是一个跨平台和语言独立的接口，它将文档表示为节点和对象的树形结构。每个元素、属性等都是文档中的一个节点。

2. **保留模式**：DOM 使用所谓的“保留模式”（Retained Mode）渲染，这意味着文档的结构和内容在内存中有一个明确的表示，即使在渲染之后也是如此。

3. **DOM操作**：当你通过 JavaScript 修改 DOM 时，浏览器会重新计算布局（Reflow）并重绘（Repaint）受影响的部分。这些操作可能比 `<canvas>` 上的像素操作更加消耗性能，尤其是在复杂或大型文档中。

4. **性能和优化**：DOM操作通常比 `<canvas>` 的像素操作慢，因为它涉及到更复杂的计算，例如布局和样式计算。为了优化性能，开发者需要精心管理DOM的更改，避免不必要的Reflow和Repaint。

### 区别总结：

- **渲染方法**：`<canvas>` 是立即模式，直接在像素级别上操作；DOM 是保留模式，通过对象和节点表示文档结构。
- **性能**：对于动态、高速的图形渲染，`<canvas>` 可能更高效；而对于需要结构化文档和样式的应用，DOM是必要的。
- **用例**：`<canvas>` 适合于游戏、图形绘制和图像处理；DOM 适合于构建和管理交互式网页布局和内容。

选择 `<canvas>` 还是 DOM 取决于应用的需求。如果需要大量的动态图形和图像处理，`<canvas>` 可能是更好的选择。如果需要构建文档结构和样式，那么使用 DOM 将是不可避免的。

## cdn的原理？如何找到最近的服务器节点？

CDN（内容分发网络）的原理是将内容缓存到遍布全球的多个服务器节点上，以便当用户请求数据时，能够从距离用户最近的节点提供数据，从而减少延迟，加快内容加载速度，并减轻原始服务器的负载。

CDN 的工作原理通常包括以下几个关键步骤：

1. **分布式数据中心**：CDN 提供商在全球各地部署许多数据中心。这些数据中心包含了缓存服务器，用来存储内容的副本。

2. **内容复制**：当内容（如网站的图片、视频、样式表、脚本等）首次被请求时，CDN 的边缘服务器会从原始服务器（即内容的源头）上获取内容，并将其缓存起来。后续的请求会被直接从缓存中提供。

3. **智能DNS解析**：当用户尝试访问使用CDN的网站时，其DNS查询会被重定向到CDN的智能DNS解析系统。这个系统会考虑多个因素，如用户的地理位置、服务器的健康状况、当前的网络状况等，来决定最佳的服务器节点。

4. **最近的服务器节点**：智能DNS解析系统会指导用户的请求到距离用户最近的边缘服务器节点或者性能最佳的节点。"最近"可以是地理上的距离最近，也可以是网络延迟最小的服务器。

5. **内容交付**：用户的请求被重定向后，边缘服务器会响应请求，如果请求的内容已经被缓存，则直接从缓存中提供给用户；如果没有缓存，则边缘服务器会从原始服务器或更靠近原始服务器的其他缓存服务器获取内容，然后提供给用户，并在本地进行缓存以备后续使用。

CDN 如何找到最近的服务器节点：

- **地理位置映射**：通过用户的IP地址，CDN可以推断出用户的大致地理位置，然后选择最近的数据中心。

- **网络延迟测量**：CDN可能会实时测量不同服务器节点到用户的网络延迟，选择延迟最小的节点。

- **实时负载监控**：CDN会监控每个节点的负载情况，避免将请求导向负载过高的服务器。

- **用户ISP（互联网服务提供商）**：有时CDN会选择与用户的ISP网络连接最佳的节点，即使这个节点在地理上不是最近的。

- **Anycast路由**：一些CDN使用Anycast技术，这意味着来自用户的请求会自动路由到接收同一IP地址的最近的服务器。

通过这些机制，CDN确保用户总是从最优的位置接收数据，这样可以显著提高速度并提供更好的用户体验。同时，CDN也保护了源服务器，避免了可能的过载问题。

## QPS 及 PV/UV 及 充值
## 数据状态管理方案
  1. vuex
    1. 数据量复杂度
      1. 数据多少（业务子模块）
        1. 服务器端状态
        2. 客户端状态  ✅
      2. 数据层级
      3. 数据相互关系
        1. 依赖
  2. Dashboard

## 如何实现监控 SDK
  1. .core
  2. .plugin
  3. .monitor
  4. 初始化参数：？
new Sentry({
    token: process.env.token,
    async options () {
        const token = await getToken()
        return {
            token
        }
    }
})


## 如何实现批量上报，节流，延迟上报


## 描述上报方案
    1. 基于数据量
    2. 上报异常的处理方案 ？
      1. indexDB
      2. 不存储，失败重试或者不处理，丢弃

## 如何处理异常采样率，去重率

  8. 429 （Rate Limit）
    1. 计数器
    2. 令牌桶 
      1. queue
        1. 10/1min: [{ timestamp, userId }, { timestamp, userId } ]
      2. incr
        1. userid-timestamp, 1min
    3. 漏筒
  9. 削峰填谷
    1. message queue
      1. kafka
      2. redis
    2. server: 100 qps，10000qps，redis-queue
      1. push
      2. pull：100/s，1s，webhook
## 如何进行重构性能优化

  1. 拆包
  2. 2.5s -> 1s
  3. （是否）沉淀优化性能方案


## 如何实现CDN 重试


在使用 CDN（内容分发网络）时，实现重试机制是为了提高资源加载的成功率。当客户端尝试从CDN获取资源失败时，可以采取一些策略来重试请求。以下是实现 CDN 重试的一些常见方法：

1. **客户端重试**:
   - **JavaScript 重试**: 当使用 JavaScript 动态加载资源（如图片、脚本、CSS等）失败时，可以通过监听错误事件来实现重试逻辑。例如，如果一个图片加载失败，可以在 `onerror` 事件中更换图片的 `src` 属性为备用CDN的URL。
   ```javascript
   const primaryCDN = 'https://cdn.primary.com/path/to/resource';
   const backupCDN = 'https://cdn.backup.com/path/to/resource';

   const img = new Image();
   img.src = primaryCDN;
   img.onerror = () => {
     console.log('Loading from primary CDN failed, trying backup CDN');
     img.src = backupCDN; // 切换到备用 CDN
   };
   document.body.appendChild(img);
   ```
   - **重试策略**: 可以定义重试次数和重试间隔，例如使用 `setTimeout` 来延迟重试，避免立即重试导致的频繁请求。

2. **服务端重试**:
   - 如果你控制着服务端，你可以在服务器端实现重试机制。当服务端从主CDN获取资源失败时，它可以尝试从其他CDN获取资源，然后将其提供给客户端。
   - 这种方法的优点是对客户端透明，用户不需要处理任何重试逻辑。

3. **DNS级别重试**:
   - **智能DNS服务**: 使用支持故障转移的智能DNS服务，可以在DNS解析层面实现重试。当主CDN不可用时，DNS查询将解析到备用CDN的IP地址。
   - 这种方法对终端用户是完全透明的，不需要更改客户端代码。

4. **使用服务工作器(Service Worker)**:
   - Service Worker可以拦截和处理网络请求，这使得它成为实现重试逻辑的理想选择。如果使用Service Worker拦截资源加载请求，并在请求失败时尝试从备用CDN加载，这可以在不影响主页面逻辑的情况下实现重试机制。

5. **第三方库或工具**:
   - 有些第三方JavaScript库提供了请求重试的功能，如Axios等，你可以使用这些库来简化重试逻辑的实现。

在实现重试逻辑时，需要考虑几个重要的因素：
- **重试次数**: 限制重试次数可以避免无限重试，这可能会导致服务降级或其他问题。
- **指数退避**: 在连续的重试中增加延迟时间，例如每次重试等待时间翻倍，这样可以减少对服务器的冲击。
- **错误类型**: 只有在确定是由于CDN问题导致的错误时才进行重试，例如网络错误或者是 5xx 类型的服务器错误。
- **监控**: 实施监控来跟踪重试发生的频率和成功率，以便对系统进行调优和问题诊断。

根据你的具体需求和环境，可以选择一个或多个策略来实现 CDN 重试机制。


## 基础数据类型，如何判断

在JavaScript中，基础数据类型（也称为原始数据类型）包括：

1. Undefined
2. Null
3. Boolean
4. Number
5. BigInt (ES2020中新增)
6. String
7. Symbol (ES6中新增)

为了判断一个变量的数据类型，你可以使用 `typeof` 操作符，它可以返回一个表示数据类型的字符串。

这里是如何使用 `typeof` 来判断各种数据类型的例子：

```javascript
let undefinedVar;
console.log(typeof undefinedVar); // "undefined"

let nullVar = null;
// 注意：这是一个历史遗留的bug，null被认为是一个对象。
console.log(typeof nullVar); // "object"

let booleanVar = true;
console.log(typeof booleanVar); // "boolean"

let numberVar = 123;
console.log(typeof numberVar); // "number"

let bigIntVar = 123n;
console.log(typeof bigIntVar); // "bigint"

let stringVar = "Hello";
console.log(typeof stringVar); // "string"

let symbolVar = Symbol("description");
console.log(typeof symbolVar); // "symbol"
```

对于 `null`，`typeof` 返回的是 `"object"`，这实际上是JavaScript最初版本的一个错误，由于历史原因一直保留到现在。如果你需要准确地判断一个变量是否是 `null`，你可以直接使用严格等于（`===`）来比较。

```javascript
if (nullVar === null) {
    console.log('nullVar is null');
}
```

另外，对于数组和对象，`typeof` 都会返回 `"object"`。如果你需要区分数组和普通对象，可以使用 `Array.isArray()` 方法来判断一个值是否为数组。

```javascript
let arrayVar = [1, 2, 3];
console.log(typeof arrayVar); // "object"
console.log(Array.isArray(arrayVar)); // true

let objectVar = {key: 'value'};
console.log(typeof objectVar); // "object"
console.log(Array.isArray(objectVar)); // false
```

对于更复杂的类型判断，你可能需要使用 `Object.prototype.toString.call()` 方法，它可以返回更精确的类型信息。

```javascript
let dateVar = new Date();
console.log(Object.prototype.toString.call(dateVar)); // "[object Date]"

let regexVar = /abc/;
console.log(Object.prototype.toString.call(regexVar)); // "[object RegExp]"
```

在准备面试时，了解这些基本的类型判断方法是很有帮助的，同时也要理解它们的边界情况和限制。


## 浏览器事件机制，如何实现事件委托，如何实现阻止冒泡


浏览器的事件机制通常包括三个阶段：捕获阶段（Capturing Phase）、目标阶段（Target Phase）和冒泡阶段（Bubbling Phase）。

1. **捕获阶段**：事件从文档的根节点往下传递到目标节点的过程。
2. **目标阶段**：事件到达目标节点，触发目标节点的监听函数。
3. **冒泡阶段**：事件从目标节点往上回传到文档的根节点的过程。

### 实现事件委托

事件委托是一种常用的事件处理模式，通过利用事件冒泡的原理，将子节点的事件监听器设置在父节点上，然后根据事件的目标元素（`event.target`）来判断子元素是否是事件的实际目标。

以下是一个简单的事件委托的例子：

```javascript
// 假设有一个列表ul，我们要为每个li元素添加点击事件
document.getElementById('myList').addEventListener('click', function(event) {
    // 检查事件的实际目标是否是我们关心的元素
    if (event.target.tagName.toLowerCase() === 'li') {
        // 在这里处理点击事件
        console.log('Clicked on li element');
    }
});
```

这段代码中，我们在父元素 `ul` 上设置了一个点击事件监听器，而不是直接在每个 `li` 元素上设置。当点击任何一个 `li` 元素时，事件会冒泡到 `ul`，然后触发监听器。监听器会检查事件的实际目标，如果是 `li` 元素，则执行相应的逻辑。

### 阻止事件冒泡

有时候，你可能不希望事件继续冒泡。你可以通过调用事件对象的 `stopPropagation` 方法来阻止冒泡：

```javascript
element.addEventListener('click', function(event) {
    // 处理点击事件
    console.log('Element clicked');

    // 阻止事件继续冒泡
    event.stopPropagation();
});
```

在这个例子中，当点击 `element` 时，会输出日志，并且事件不会继续冒泡到父元素。

### 注意

在实际使用事件委托时，你需要注意以下几点：

- 事件委托主要适用于那些自然会冒泡的事件，如 `click`、`mousedown` 等。并非所有事件都会冒泡，例如 `focus`、`blur` 和 `load` 事件就不会冒泡。
- 事件委托可以减少事件监听器的数量，提高性能，尤其是在有大量相似子元素需要处理事件时。
- 使用事件委托时，确保委托的事件是父元素和子元素都需要响应的事件类型。
- 当事件的默认行为不是你想要的时，可以使用 `event.preventDefault()` 方法来取消事件的默认行为。比如，阻止链接的默认导航行为或表单的提交行为。

## 描述防抖和节流，实现节流，防抖代码


## React的优化策略有哪些？

在React应用中，性能优化通常是为了减少不必要的渲染次数、减少组件的更新开销、优化组件加载时间和管理状态更新的效率。以下是一些常见的React性能优化策略：

### 1. 使用不可变数据结构
使用不可变数据可以帮助避免不必要的渲染。当你使用不可变数据时，可以简单地比较引用来检测变化，这比深度比较要快得多。

### 2. PureComponent 和 React.memo
- **PureComponent**: 通过浅比较props和state来减少不必要的渲染。如果组件的props和state结构简单，那么使用 `PureComponent` 可以减少渲染次数。
- **React.memo**: 是一个高阶组件，它与 `PureComponent` 类似，但用于函数组件。它会阻止组件在相同props的情况下重新渲染。

### 3. shouldComponentUpdate
在类组件中，可以使用 `shouldComponentUpdate` 生命周期方法来控制组件是否应该更新。通过返回 `true` 或 `false` 来决定组件是否进行更新。

### 4. 使用key属性
在渲染列表时，确保每个列表项都有一个唯一的 `key` 属性。这可以帮助React识别哪些项已经改变、添加或删除，从而减少不必要的元素创建和销毁。

### 5. 动态导入和代码分割
使用 `React.lazy` 和 `Suspense` 或其他库（如 `Loadable Components`）来实现动态导入和代码分割，从而将代码分割成小的块，并按需加载。

### 6. 避免内联函数和对象
在渲染方法或函数组件中直接定义内联函数和对象会在每次渲染时创建新的函数和对象，这可能会导致子组件不必要的重新渲染。

### 7. 使用useCallback和useMemo
- **useCallback**: 缓存函数，以便在依赖项不变的情况下跨渲染周期重用相同的函数实例。
- **useMemo**: 缓存计算结果，只有在依赖项改变时才重新计算。

### 8. 避免不必要的DOM操作
尽量减少DOM操作，因为它们可能很昂贵。使用CSS动画代替JavaScript动画，使用CSS布局优化而不是通过JavaScript计算布局。

### 9. 使用Web Workers
对于复杂计算，可以使用Web Workers将计算从主线程移出，以避免阻塞UI渲染。

### 10. 状态提升和Context
适当使用状态提升和Context API来管理状态，避免不必要的组件嵌套和重新渲染。

### 11. 使用Fragment避免额外的DOM节点
使用 `React.Fragment` 或 `<>` 空标签来避免创建不必要的DOM节点，这有助于减少DOM树的大小。

### 12. 监控和分析
使用React DevTools进行性能分析，识别瓶颈。Profiler可以帮助你了解组件的渲染时间和原因。

### 13. 服务端渲染(SSR)或静态站点生成(SSG)
使用服务端渲染或静态站点生成可以提高首次加载性能，因为用户会直接收到一个渲染好的页面。

### 14. 懒加载图片和组件
对于图片和组件，可以实现懒加载，即只有当它们出现在视口中时才开始加载。

性能优化通常涉及到权衡，需要根据具体情况来决定使用哪种策略。在进行优化之前，最好先进行性能分析，确定真正的性能瓶颈所在。


## 前端工程化的理解 ？

前端工程化是指在前端开发过程中，应用软件工程的原则和方法，以提高开发效率、降低维护成本、保证项目质量和可扩展性的一系列工作。前端工程化主要包括以下几个方面：

### 1. 模块化
模块化是指将复杂的系统分解成高内聚、低耦合的模块，使得每个模块可以独立开发、测试、维护。在前端开发中，模块化可以应用于JavaScript、CSS和HTML。比如，使用ES6的模块系统、CSS的预处理器如Sass或Less以及组件化的模板引擎。

### 2. 组件化
组件化是模块化的进一步深化。它将UI划分为独立的、可复用的组件，每个组件包含自己的逻辑和样式。在React、Vue、Angular等现代前端框架中，组件化是核心概念之一。

### 3. 规范化
规范化主要是指制定一系列标准和规范来指导开发工作，包括编码规范、组件库使用、Git分支管理、commit信息规范等，以确保团队成员之间的协作效率和代码的一致性。

### 4. 自动化
自动化是工程化中非常重要的一环。它包括代码构建、测试、部署等自动化流程。通过自动化工具（如Webpack、Babel、ESLint、Jest、Cypress等）来自动完成这些重复性的工作，提高开发效率和代码质量。

### 5. 性能优化
性能优化是前端工程化的重要目标之一。它包括加载性能优化（如代码分割、懒加载、资源压缩）、运行性能优化（如虚拟DOM、智能更新）和渲染性能优化（如CSS优化、避免回流和重绘）。

### 6. 工具链
工具链是支持前端工程化的工具和服务的集合，通常包括包管理器（如npm、yarn）、构建工具（如Webpack、Rollup）、代码转译（如Babel、TypeScript）、代码质量工具（如ESLint、Prettier）、测试框架（如Jest、Mocha）等。

### 7. 持续集成和持续部署（CI/CD）
通过持续集成（CI）和持续部署（CD）的实践，可以确保代码的质量和快速迭代。CI/CD可以帮助开发者在代码提交后自动运行测试、构建和部署到服务器。

### 8. 版本管理和依赖管理
合理地管理项目版本和依赖关系对于项目的长期维护至关重要。这包括使用版本控制系统（如Git）、遵循语义化版本控制规范（SemVer）、以及有效管理项目的依赖库。

### 9. 开发环境和生产环境的分离
确保开发环境、测试环境和生产环境的配置分离，可以帮助模拟不同的运行环境，减少因环境不一致导致的问题。

### 10. 代码审查和文档
代码审查是提高代码质量、分享知识和技术债务管理的重要手段。同时，良好的文档可以帮助新成员快速上手，也是项目可维护性的关键。

总体来说，前端工程化是为了解决非功能性的问题，让开发者能够专注于功能开发，提高开发效率和项目质量，最终为用户提供更好的产品。随着技术的发展，前端工程化本身也在不断进化，涌现出更多的工具和实践。


## 移动端适配方案

移动端适配是前端开发中的一个重要方面，主要是为了确保网页或应用界面在不同设备和屏幕尺寸上都能提供良好的用户体验。适配方案主要包括以下几种方法：

### 1. 响应式网页设计 (Responsive Web Design, RWD)
响应式设计通过使用流体网格、媒体查询和可伸缩的图片来实现不同设备上的视觉一致性。CSS3中的媒体查询（Media Queries）允许你根据不同的屏幕尺寸、分辨率等设备特性来应用不同的样式规则。

```css
@media screen and (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}
```

### 2. 移动优先 (Mobile First)
在移动优先的策略中，设计师和开发者会先为移动设备设计网站，然后再扩展至桌面版本。这通常意味着在CSS中先编写针对小屏幕的样式，然后通过媒体查询添加额外的样式来适配更大的屏幕。

### 3. 灵活布局 (Flexible Layout)
使用百分比、vw（视口宽度）、vh（视口高度）等相对单位而不是固定单位（如像素）来创建布局，可以使布局更加灵活，更容易适应不同屏幕尺寸。

### 4. REM单位
REM是相对于根元素（html元素）的字体大小的单位。通过改变根元素的字体大小，可以实现对整个应用或网站的缩放。

```css
html { font-size: 62.5%; }
body { font-size: 1.4rem; } /* equals to 14px */
h1 { font-size: 2.4rem; } /* equals to 24px */
```

### 5. 视口单位 (Viewport Units)
视口单位，如vw（视口宽度的1%）和vh（视口高度的1%），可以用来创建相对于视口大小的布局和字体大小。

### 6. 图片和媒体的适配
使用CSS的 `background-size` 属性和HTML的 `srcset` 属性来确保图片在不同分辨率下都能正确显示。

```html
<img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" src="medium.jpg" alt="Responsive image">
```

### 7. 框架和工具
使用前端框架如Bootstrap、Foundation等，它们提供了一套预定义的响应式网格系统和组件。

### 8. 设备像素比 (Device Pixel Ratio, DPR)
考虑设备像素比来为高清屏幕提供高分辨率的图片。

### 9. 触控优化
确保按钮、链接等触控目标的大小足够大，以适应手指触控操作。

### 10. JavaScript适配
在某些情况下，可能需要使用JavaScript来动态调整某些样式或元素，以适应屏幕尺寸的变化。

### 11. PostCSS、Sass、LESS等预处理器
使用预处理器来帮助生成响应式设计中需要的重复性代码。

### 12. 测试和调试
使用开发者工具的设备模拟功能以及在真实设备上进行测试，以确保适配方案的有效性。

移动端适配是一个持续的过程，需要不断测试和调整来适应新设备和新的屏幕尺寸。随着技术的发展，可能会出现新的适配方法，但上述方法构成了目前移动端适配的基础。



## Chrome PC版文档流支持的最小字号是什么？如何在Chrome中展示更小的字号？

如果你希望在Chrome中实现小于12px的字体大小，虽然直接设置字体大小可能会受到浏览器的最小字号限制，但你可以采用一些技术手段或视觉技巧来达到类似效果。这里有几种方法：

1. **使用缩放**:
   - 你可以通过缩放整个元素来间接减小文字的显示大小。例如，如果你将一个元素及其内容缩小到原始尺寸的一半，那么即使字号设置为12px，实际上看起来也只有6px那么大。CSS的`transform: scale()`属性可以用于此目的。
     ```css
     .small-text {
       transform: scale(0.5);
       transform-origin: top left;
     }
     ```

2. **使用视觉效果**:
   - 利用视觉对比效果，例如将小字号的文本放置在大字号文本旁边，可以使得小字号文本在视觉上看起来更小。这不是直接减小字体大小，而是一种视觉错觉。

3. **SVG文本**:
   - 将文本作为SVG元素，然后调整SVG的大小。SVG元素的大小不受浏览器最小字号的限制，因此你可以将文本设置为任意小的尺寸。SVG也支持文本元素，这意味着你可以在SVG内部使用`<text>`标签，并通过调整SVG尺寸来控制文本大小。
     ```html
     <svg width="100" height="30">
       <text x="0" y="15" font-family="Arial" font-size="6px">Your text here</text>
     </svg>
     ```

4. **Canvas绘制**:
   - 使用HTML5 Canvas绘制文字也是一种可能的方法。Canvas允许你以编程方式绘制图像和文本，包括非常小的字号。这种方法给了你更多的灵活性，但牺牲了一些文本的可访问性。

每种方法都有其优缺点，比如使用`transform: scale()`可能会导致文本变得模糊，而使用SVG或Canvas则可能影响到文本的可选中性和可访问性。因此，在决定使用哪种方法之前，考虑你的具体需求和目标用户的体验非常重要。


## PC移动端内容适配需要注意什么，涉及到哪些技术？

在进行PC和移动端内容适配时，目标是确保网站或应用在不同设备上都能提供良好的用户体验。这通常需要关注布局的响应式设计、图像的优化、交互元素的适应性，以及加载时间的优化等多个方面。以下是一些主要技术和策略：

### 1. 响应式网页设计 (Responsive Web Design, RWD)
- **媒体查询（Media Queries）**：CSS媒体查询允许你根据不同的屏幕尺寸、分辨率等条件应用不同的样式规则。
- **流式布局（Fluid Layouts）**：使用百分比宽度而非固定宽度，使布局能够根据父容器的大小动态调整。
- **弹性布局（Flexbox）**：CSS的一种布局模式，能够让容器内的项能够按比例分配空间，对于复杂的布局非常有用。
- **CSS网格（CSS Grid）**：强大的布局系统，可以处理二维布局，对于构建复杂的网页布局非常有帮助。

### 2. 图像和媒体优化
- **自适应图片（Responsive Images）**：使用`<picture>`元素或`srcset`属性，根据设备加载适当大小的图片。
- **懒加载（Lazy Loading）**：只加载用户可见区域的内容，提高加载速度和性能。

### 3. 交互元素的适应性
- **触摸优化**：确保按钮、链接等元素在触摸屏上易于操作，可能需要调整元素的大小和间距。
- **表单优化**：确保表单在各种设备上都易于填写，包括适当的输入类型和大小。

### 4. 性能优化
- **代码分割（Code Splitting）**：只加载用户当前需要的代码，减少首次加载时间。
- **压缩资源（Minification）**：压缩CSS、JavaScript和图片文件，减少文件大小，提高加载速度。
- **使用内容分发网络（CDN）**：加速全球用户的内容加载速度。

### 5. 可访问性 (Accessibility)
- 确保网站对所有用户，包括使用辅助技术的人士，都是可访问的。这包括适当的语义标记、可访问性标准的遵守等。

### 6. 测试和验证
- **跨浏览器和设备测试**：使用工具和真实设备测试你的网站或应用，确保在不同环境中都能正常工作。
- **性能测试**：使用工具（如Google PageSpeed Insights、Lighthouse）来评估和优化网站性能。

结合以上技术和策略，可以创建适应不同屏幕尺寸和设备的网站和应用，从而提供无缝且高效的用户体验。

## React 的Hook是为了解决什么问题？

React Hooks是React 16.8版本引入的一个重要特性，它允许你在不编写类组件的情况下使用state和其他React特性。Hooks解决了多个在React开发中长期存在的问题：

### 1. 复用状态逻辑变得简单
在Hooks之前，复用状态逻辑通常需要高阶组件（HOCs）或渲染属性（Render Props）等模式。这些模式虽然强大，但会增加组件树的复杂性，并使得代码难以理解。Hooks允许你在不改变组件结构的情况下复用状态逻辑，使得代码更加清晰和简洁。

### 2. 组件难以理解的问题
类组件要求开发者理解JavaScript中的`this`关键字和类的特性，这对于一些开发者来说可能是一个学习障碍。此外，类组件中生命周期方法的使用使得相关逻辑分散在多个地方，增加了理解和维护的难度。Hooks通过使用函数组件来管理状态和副作用，避免了`this`的复杂性，并将相关逻辑组织在一起，使得组件更易于理解和维护。

### 3. 复杂组件变得难以管理
在大型应用中，随着组件变得越来越复杂，管理其内部状态和生命周期变得困难。Hooks提供了如`useState`、`useEffect`、`useContext`等API，让状态管理和副作用的处理更加模块化和可预测，简化了复杂组件的开发和管理。

### 4. 优化性能的困难
在类组件中，优化性能（如防止不必要的渲染）通常需要使用额外的生命周期方法（如`shouldComponentUpdate`）或者React.memo等API。Hooks通过`useMemo`和`useCallback`等Hook，提供了更简单的方式来优化组件的性能。

### 5. 更好的适配未来的React特性
Hooks设计时考虑了未来React的并发模式（Concurrent Mode）和其他新特性的适配。使用Hooks开发的组件将能更好地利用React未来的性能改进和新特性。

总的来说，React Hooks提供了一种更简单、更直观的方式来编写组件，通过解决状态逻辑复用、组件复杂性管理和性能优化等问题，让React开发变得更加高效和愉悦。

## 如何监听localStorage里数据的变化？



## 平时用哪些大模型？通过什么工具使用大模型，对大模型应用有什么看法


## 如何避免父子组件的数据不一致


## 如何处理后端返回的重复数据


## 瀑布流如何优化


## 网站SEO优化策略



## LLM常用的Prompt

从 Fooocus 取

## 大模型换脸

开源换脸 instandID

调试工具 ComfyUI-InstantID

## 炼lora

kohya_ss

## 生图

Stable diffution

## 合成语音用了哪些服务

elevenlabs

ElevenLabs 的平台提供了强大的语音合成和声音克隆技术，能够根据少量的音频样本创建逼真的语音克隆。他们的技术支持多种语言和方言，理论上可以用于模仿特定角色的声音，虽然在实践中可能需要考虑版权等法律问题。

## 保持人物一致性

在使用大模型，特别是像LoRA这样的模型来生成包含特定人物的冒险故事时，保持人物特征（如衣着绘制）的一致性是一个重要考虑。以下是一些技巧和方法，以确保故事中人物特征的连贯性：

### 明确人物特征

1. **详细描述人物**：在故事开始之前，提供一个详尽的人物描述，包括他们的外貌、性格、喜好，以及特别强调的是他们的着装。这样做可以确保在故事生成过程中，这些关键信息被重视和保留。
   
2. **使用角色卡**：创建一个或多个“角色卡”，详细记载每个人物的信息，包括衣着风格。在生成故事的过程中，可以引用这些角色卡以确保一致性。

### 故事生成技巧

1. **重复强调关键特征**：在故事推进的过程中，适时重复提及人物的关键特征，比如他们特定的衣着。这不仅能帮助保持一致性，也能增强读者对人物形象的记忆。

2. **设置模板句子**：为人物的行动或描述设置一些模板句子，这些句子中包含了人物的关键特征。例如，“穿着他标志性蓝色斗篷的John走进了房间”，这样的句子在故事中反复使用可以强化人物形象。

### 交互式细化

1. **分步生成并修正**：在故事生成的每个阶段，检查人物的描述是否与你设置的角色卡一致。如果发现不一致之处，可以手动修正或提供反馈给模型，要求它在接下来的内容中纠正这些不一致。

2. **提问和校对**：在故事生成的过程中，不妨设立几个检查点，问模型一些关于人物特征的问题，看是否与你的设定一致。这可以帮助你发现可能的不一致之处，并及时进行调整。

### 利用定制化模型能力

如果可能，可以考虑定制或调整模型的某些参数，使其更加偏好于保留关键人物特征的描述。虽然这需要一定的技术知识和资源，但对于长期项目或高质量要求的项目而言，这是一个值得考虑的选项。

通过这些方法，你可以在使用LoRA或其他大模型生成包含特定人物的故事时，更好地保持人物特征的一致性，从而提升故事的连贯性和吸引力。

## package-lock.json锁版本号的意义，如果在 package.json 中写死会怎么样？


`package-lock.json` 文件在JavaScript项目中扮演着重要的角色，尤其是在使用npm作为包管理工具时。它的主要目的是锁定依赖项的版本号，以确保在不同的开发环境和部署时能够获得一致的依赖项安装结果。以下是`package-lock.json`的一些关键作用：

1. **确保一致性**：`package-lock.json` 记录了整个依赖树中所有包的确切版本号，包括子依赖项。这意味着每个团队成员和部署环境都会安装相同版本的依赖项，避免了“在我的机器上可以运行”的问题。

2. **加快安装速度**：由于`package-lock.json`中记录了依赖树的确切结构，npm可以跳过解析package.json的过程，直接安装依赖项，从而加快了安装速度。

3. **审计和安全**：`package-lock.json` 文件允许开发者审计当前安装的包的版本，这对于跟踪安全漏洞和进行安全审计是非常有用的。

如果在`package.json`中写死了版本号，即指定了具体的版本而不是使用版本范围（例如，使用`"express": "4.17.1"`而不是`"express": "^4.17.1"`），你会得到以下效果：

1. **版本控制**：项目将总是使用指定的版本，这减少了由于意外升级导致的不一致性。

2. **减少灵活性**：由于版本被固定，自动接收依赖项的补丁和次要更新（通常是安全和bug修复）变得不可能，这可能会导致你错过重要的更新。

3. **潜在的依赖冲突**：如果你的项目依赖其他包，这些包可能依赖于相同库的不同版本，固定版本可能会导致依赖冲突，特别是在大型项目中。

4. **维护成本**：每次需要升级依赖项时，你需要手动更改`package.json`文件中的版本号，这增加了维护成本。

总的来说，`package-lock.json`为项目提供了更全面的版本控制和一致性保障，而在`package.json`中写死版本号虽然可以提供严格的版本控制，但会牺牲更新的灵活性和可能增加维护成本。通常最佳实践是将`package-lock.json`文件提交到版本控制系统中，并依赖它来管理项目的依赖项版本。

## 控制故事剧情

- 套一些小说的模版
- 碎片化叙事

## 鉴别什么是一个好故事

- 用户点击量
- 故事延伸的长度


## 我在用ChatGPT创建一个多场景故事，但我对场景里面出现的元素和人物不满意，如何对prompt进行调优


创建多场景故事时，优化prompt以提升元素和人物的描述质量是关键。以下是一些调优策略：

### 1. 细化描述
提供更多细节来描述场景、人物和元素。比如，不仅仅说“森林”，而是描述“雾气缭绕的古老森林，阳光透过密集的树冠洒下斑驳的光影”。

### 2. 使用感官细节
包括视觉、听觉、嗅觉、触觉和味觉细节，让场景更加生动。例如，“空气中弥漫着湿润的泥土气息，偶尔可以听到远处小溪潺潺的流水声”。

### 3. 明确目的和情感
在描述时，明确场景和人物的目的、情感状态或内在冲突。例如，“他站在山巅，眺望着下方蜿蜒的河流，内心充满了对未来的渴望和不安”。

### 4. 变化视角
尝试从不同的视角讲述故事，比如第一人称、第三人称或是全知角度。这可以为故事带来新的视角和深度。

### 5. 使用比喻和象征
通过比喻和象征手法增加层次感，让读者在字面意义之外发现更深的含义。例如，“那座孤独的山峰就像是一位沉默的守望者，静静地注视着下面的世界”。

### 6. 考虑动态变化
描述场景和人物时，考虑时间的流逝或情境的变化。这样的动态描述可以增加故事的紧张感和兴趣度。

### 示例调优后的Prompt

假设原始prompt是：“在森林里，一个男孩找到了一把剑。”

调优后的prompt可能是：“在一个充满迷雾的古老森林深处，一名年轻的探险者偶然发现了埋藏在古老树根下的传说中的剑。阳光透过稠密的树冠，将斑驳的光影投射在这把散发着神秘光芒的古剑上。男孩的心跳加速，眼前这把剑不仅是通往未知世界的钥匙，也是他勇气的试炼。”

这样的描述不仅让场景和人物变得更加生动和具体，也为故事增添了更多情感和背景深度。


### React 和Vue的区别是什么？


React和Vue是两个非常流行的JavaScript库和框架，它们都用于构建用户界面，特别是单页面应用。这两者之间有很多相似性，但也有一些关键的区别。以下是一些主要的区别：

1. **设计理念**：React更倾向于成为一个灵活的库，让开发者自由选择需要的部分，然后可以与其他库一起使用。Vue则更倾向于成为一个完整的框架，提供开箱即用的功能。

2. **模板和JSX**：React使用JSX（JavaScript XML）来创建用户界面，这是一种JavaScript的扩展语法，允许HTML代码直接嵌入到JavaScript代码中。而Vue则使用了基于HTML的模板语法，开发者可以使用熟悉的HTML标签和语法来构建用户界面。

3. **数据绑定**：Vue提供了双向数据绑定，这意味着当模型的状态改变时，视图会自动更新，反之亦然。React则主要使用单向数据流，这意味着数据总是从父组件流向子组件。

4. **性能**：在大多数情况下，React和Vue的性能都非常接近。但是，由于Vue的依赖追踪和异步队列更新，某些情况下Vue可能会有更好的性能。

5. **社区和生态系统**：React由Facebook开发并维护，社区非常活跃，有大量的第三方库和工具。Vue虽然社区规模较小，但是它的文档非常完善，对新手友好，也有一套完整的官方库和工具。

6. **学习曲线**：通常认为，Vue的学习曲线相对较平缓。它的API设计更直观，文档也更易于理解。而React的学习曲线可能会更陡峭一些，特别是对于那些不熟悉JSX和函数式编程的开发者。

以上就是React和Vue的一些主要区别。具体选择哪一个，取决于项目的需求、团队的熟悉程度以及个人的喜好。

### React的Class 和 function 有什么区别？

React中的类组件（Class components）和函数组件（Function components）都可以用来创建组件，但它们在语法和功能上有一些重要的区别。

1. **语法**：类组件需要定义一个扩展自 `React.Component` 的类，然后在该类中定义一个 `render` 方法。这个 `render` 方法返回组件的 JSX 结构。函数组件则更简洁，它只是一个返回 JSX 的函数。

2. **状态（State）**：在 React 16.8 之前，只有类组件可以有自己的状态。函数组件是无状态的，它们只接受 `props` 并返回 JSX。但是，随着 React 16.8 中 `Hooks` 的引入，函数组件现在也可以有自己的状态和副作用。

3. **生命周期方法**：类组件有生命周期方法，比如 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 等。这些方法在特定的时间点被调用，允许在组件的生命周期中执行特定的操作。在引入 `Hooks` 之前，函数组件没有这些生命周期方法。但是，现在我们可以使用 `useEffect` Hook 在函数组件中执行类似的操作。

4. **this 关键字**：在类组件中，你需要使用 `this` 关键字来访问 `props`、`state` 和类方法。在函数组件中，你不需要（也不能）使用 `this`。

5. **性能**：函数组件通常比类组件更轻，更快，因为它们没有类组件的生命周期方法和渲染过程中的一些额外开销。然而，随着 `Hooks` 的使用，这个差异已经变得不那么显著。

6. **Hooks**：只有函数组件可以使用 `Hooks`。`Hooks` 是一种可以让你在函数组件中 "挂钩" 到 React 状态和生命周期特性的新功能。

总的来说，随着 `Hooks` 的引入，函数组件和类组件的功能已经非常接近。但是，它们在语法和使用方式上仍有一些差异。

### 讲一下React的fiber

React Fiber 是 React 16 中引入的一种新的核心算法，它主要目的是增强 React 在大型应用中的性能并扩展其能力。

Fiber 实质上是对 React 的内部实现进行了重写，但这并不会影响到大多数 React 开发者写代码的方式。以下是一些 Fiber 的主要特性和优点：

1. **增量渲染（Incremental Rendering）**：这是 Fiber 的主要特性，它允许 React 在渲染过程中将工作拆分成多个块，并在需要时暂停和恢复这些工作。这使得 React 可以在处理大型更新时避免阻塞主线程，从而保持界面的流畅性。

2. **并发模式（Concurrent Mode）**：这是 React Fiber 可以实现的另一个重要特性，它允许 React 在后台预渲染组件，然后在合适的时机快速切换到这些新的组件。这可以帮助避免在用户交互时出现界面卡顿。

3. **优先级调度（Prioritization）**：Fiber 可以根据更新的重要性为不同的更新分配优先级。例如，用户的交互（如点击或滚动）会被赋予较高的优先级，而后台的数据更新则会被赋予较低的优先级。

4. **更好的错误边界（Error Boundaries）**：Fiber 引入了一种新的生命周期方法 `getDerivedStateFromError` 和 `componentDidCatch`，允许你在子树中捕获 JavaScript 错误，防止整个应用崩溃。

5. **对动画和布局的支持**：Fiber 的架构使得 React 可以更好地支持动画和布局，尽管这些特性在写这篇文章时（2021年）还未完全实现。

总的来说，React Fiber 是对 React 的一个重大改进，它使得 React 在处理大型和复杂应用时更加高效，并为未来的功能扩展打下了基础。



### 讲一下React的事件绑定


在React中，事件绑定是一个重要的概念，因为它允许你在用户与应用的界面交互时执行特定的函数或方法。React的事件处理和DOM的事件处理有一些不同。以下是一些关键的点：

1. **事件命名**：React事件使用驼峰命名法，而不是小写。例如，在JavaScript中，我们使用`onclick`，而在React中，我们使用`onClick`。

2. **事件处理函数**：在React中，你通常会将事件处理函数作为组件的方法。这些方法通常在组件类中定义，或者在函数组件中作为函数定义。

3. **事件绑定**：在React中，你需要将事件处理函数绑定到组件的实例上。这是因为在JavaScript中，类的方法默认不会将`this`绑定到实例上。你可以在构造函数中使用`.bind(this)`来绑定事件处理函数，或者使用箭头函数，箭头函数会自动将`this`绑定到定义它的作用域。

例如，以下是一个类组件中的事件绑定：

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { clicked: false };

    // 使用.bind(this)绑定事件处理函数
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState({ clicked: true });
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.clicked ? 'Clicked!' : 'Click me'}
      </button>
    );
  }
}
```

你也可以使用箭头函数来自动绑定`this`：

```jsx
class MyComponent extends React.Component {
  state = { clicked: false };

  // 箭头函数会自动绑定this
  handleClick = () => {
    this.setState({ clicked: true });
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.clicked ? 'Clicked!' : 'Click me'}
      </button>
    );
  }
}
```

在函数组件中，你可以直接在JSX中使用箭头函数，或者使用`useCallback` Hook：

```jsx
function MyComponent() {
  const [clicked, setClicked] = React.useState(false);

  const handleClick = () => {
    setClicked(true);
  };

  return (
    <button onClick={handleClick}>
      {clicked ? 'Clicked!' : 'Click me'}
    </button>
  );
}
```

4. **事件对象**：React中的事件被称为“合成事件”（SyntheticEvent），这是对浏览器原生事件的跨浏览器包装。它们的API与原生事件相同，所以你可以像处理常规JavaScript事件一样处理它们。

5. **阻止默认行为**：在React中，你可以通过调用`event.preventDefault()`来阻止事件的默认行为，就像在普通的JavaScript事件中一样。

以上就是React中事件绑定的基本概念。


### Vue和React的区别是什么？为什么选择React



### 什么是MVVM ，什么是MVC，二者有什么区别？

### 如何提升网站的Google SEO


- 域名包含关键词（夸张一些，买域名，做答案）
- url不要包含中文，降低链接层次，层级超过三层，可以考虑开子域名
- 注意title, description, keyword
- sitemap.xml
- 不要包含死链
- 标题可以长一些
- 网页更新时间也重要
- 用知名站的反向链接提升排名，比如Github优质仓库
- 常看Google search console报告

### 运行的Node.js忽然内存占用飙升，如何排查和解决


### 如何将箭头函数转成function函数

转换为

### css和less的区别

CSS (Cascading Style Sheets) 和 LESS 都是用于描述 HTML 文档样式的语言。不过，LESS 提供了比 CSS 更强大的功能，包括变量、嵌套、混合（mixins）、运算和函数等。以下是这两者的主要区别：

1. **变量**：在 CSS 中，你不能定义变量。例如，如果你有一个特定的颜色值，你需要在每个使用它的地方重复这个值。如果你需要更改这个颜色，你需要找到并更改所有使用它的地方。在 LESS 中，你可以定义变量，例如 `@primary-color: #4D926F;`，然后在你的样式表中使用这个变量。

2. **嵌套**：CSS 不支持嵌套规则，这意味着你需要为每个元素和其子元素分别定义样式。LESS 支持嵌套，这使得你可以在一个规则内部定义另一个规则，这可以使代码更加整洁和易于管理。

3. **混合（Mixins）**：这是 LESS 的一个强大功能，它允许你定义一组CSS声明，然后在需要的地方重复使用。CSS 不支持这个功能。

4. **函数和运算**：LESS 提供了一些内建函数，例如用于处理颜色的函数。它也支持简单的数学运算，这在处理像字体大小和布局的计算时非常有用。CSS 不支持这些功能。

5. **编译**：CSS 是一种标准的 web 技术，所有的浏览器都可以直接解析。然而，LESS 不是一种标准的 web 技术，它需要被编译成 CSS 才能被浏览器解析。这意味着使用 LESS 需要一个编译步骤，但这也为你提供了更多的可能性和灵活性。

总的来说，LESS 提供了一些强大的功能，可以使你的 CSS 更容易管理和维护。然而，由于它需要编译，所以在使用 LESS 时，你需要考虑到这个额外的步骤。

### 如何将less的嵌套解析为css




### 如何实现不同地区的用户访问不同区域的服务器

这种方法在一些特定的情况下可能是有效的，但它也有一些显著的缺点：

1. **缺乏灵活性**：如果服务器的IP地址发生变化，或者你想改变服务器的分配策略，你需要更新并重新发布所有的客户端。这可能会带来很大的运维负担。

2. **无法处理移动用户**：如果一个用户从一个地区移动到另一个地区，他们的客户端仍然会尝试连接到原来的服务器，即使那可能不是最佳的选择。

3. **无法处理服务器故障**：如果一个服务器出现故障，客户端将无法自动切换到其他服务器。除非你在客户端中实现了某种形式的故障检测和切换机制，否则用户可能会遇到服务中断。

4. **安全问题**：公开服务器的IP地址可能会增加被攻击的风险，特别是针对特定地区的服务器的定向攻击。

因此，虽然这种方法可能在一些简单的情况下工作，但在大多数情况下，使用更灵活、更健壮的方法（如我之前提到的地理定位DNS、CDN、负载均衡器或GSLB）可能是更好的选择。

### 如何实现分布式服务器的数据同步

### 如果Web页面卡顿应该如何解决

- 减少高频DOM操作

- 将需要大量计算的js代码放入Web Workers

- 检查网络请求是否过多，网络请求的回调函数是否长期占用主进程的时间

### 如何分析10万用户访问网站的体验


### AIGC如何为销售业务带来增长

- 更懂用户的自动化客服

- 更多软文，提升SEO

- 定价策略

### 性能优化

https://web.dev/articles/vitals


#### LCP Large content paint

从用户开始加载网页到最大的图片或文本块在视口中呈现之间的时间

LCP (Largest Contentful Paint): 这个指标衡量的是页面主要内容渲染的速度。在用户访问一个网页时，他们期望能够尽快看到页面的主要内容。LCP度量的是从页面开始加载到页面主要内容（例如一个大的图片或者文本块）渲染完成的时间。理想的LCP时间应该在2.5秒以内。

LCP 可以进一步细分为以下两个阶段：

TTFB (Time to First Byte): 这个指标度量的是从用户请求一个页面到他们的浏览器接收到这个页面的第一个字节的时间。这个时间包含了网络延迟，服务器处理时间等等。如果 TTFB 时间过长，可能是服务器处理时间过长或者网络连接问题，这都会导致用户等待页面加载的时间过长。

First Paint/First Contentful Paint: 这两个指标度量的是浏览器开始绘制内容到屏幕的时间。First Paint 是浏览器开始绘制任何内容（可能是背景色，图片等）到屏幕的时间，而 First Contentful Paint 是浏览器开始绘制DOM内容（例如文本，图片等）到屏幕的时间。这两个指标可以帮助我们理解用户何时开始看到页面的内容。

TTFB 第一个字节所需时间 0.8秒

**优化 LCP**：

优化服务器响应时间：可以通过改进服务器端的代码，使用更快的网络连接，或者使用内容分发网络 (CDN) 来提高服务器响应速度。

优化资源加载速度：可以通过压缩文件，使用有效的缓存策略，或者使用预加载 (preload) 或预获取 (prefetch) 技术来提高资源加载速度。

优化渲染速度：可以通过避免大量的 JavaScript 运行阻塞页面渲染，优化 CSS，或者使用懒加载等技术来提高渲染速度。


#### CLS Cumulative Layout shift

- 为广告预留空间
- 尽量获取图片的真实尺寸比例，如果拿不到，则尽量给更多的预留空间
- 用好缓存

CLS (Cumulative Layout Shift): 这个指标衡量的是页面在加载过程中的视觉稳定性。如果一个页面在加载过程中元素位置频繁变动，可能会导致用户的操作被打断，例如误点击。CLS度量的是页面在加载过程中所有的布局变动的总和。理想的CLS得分应该低于0.1。

**优化 CLS**：

避免插入新的内容到已经存在的内容上方：这可能会导致页面的内容向下移动，从而引起布局变动。

为图片和视频等媒体元素指定宽度和高度：这可以让浏览器在元素还没有完全加载之前就知道它们将占据的空间，从而避免布局变动。

避免动画产生的布局变动：可以通过使用 transform 属性来进行动画，而不是改变元素的位置或大小。


#### INP interaction to next paint


FID (First Input Delay): 这个指标衡量的是页面的交互性。用户在访问一个页面时，他们期望能够尽快与页面进行交互，例如点击一个按钮或者输入文本。FID度量的是用户首次交互（例如点击一个链接）到页面开始处理这个交互的延迟。理想的FID时间应该在100毫秒以内。

**优化 FID**：

减少 JavaScript 的执行时间：可以通过优化 JavaScript 代码，避免长时间的 JavaScript 任务，或者使用 Web Workers 来在后台线程运行 JavaScript，从而减少主线程的负载。

使用浏览器的交互性优化特性：例如，可以使用 passive listeners 来改进滚动和缩放的性能，或者使用 requestIdleCallback 来在浏览器空闲时运行代码。



## pnpm对比npm有哪些优势


`pnpm` 相对于 `npm` 有几个主要的优势，这些优势使其成为许多开发项目的首选包管理器。以下是 `pnpm` 相比 `npm` 的几个关键优势：

### 1. 更高效的磁盘空间利用

- **磁盘空间共享**：`pnpm` 使用内容寻址文件系统来存储 npm 包的所有版本。这意味着如果多个项目使用相同版本的一个包，这个包在磁盘上只会存储一次，减少了磁盘空间的使用。
- **硬链接**：`pnpm` 通过创建硬链接或符号链接到存储中的单一版本，来在 `node_modules` 文件夹中“安装”包。这样做既节省了空间，又使得每个项目都能够访问它需要的包。

### 2. 更快的安装速度

- **并行安装**：`pnpm` 能够同时安装多个包，利用网络和磁盘资源，提高了安装速度。
- **增量安装**：对于已经下载和安装的包，`pnpm` 可以只更新改变了的部分，这样可以大大减少安装时间。

### 3. 严格的包依赖隔离

- **扁平化的 node_modules**：与 `npm` 和 `yarn` 不同，`pnpm` 创建了一个接近传统 node 解析算法的 `node_modules` 目录结构，但它确保包只能访问其依赖项，这提高了项目的安全性和一致性。

### 4. 支持工作空间

- **Monorepo 支持**：`pnpm` 自然支持 Monorepo，这是一种将多个代码库存储在同一个仓库（repository）中的做法。这使得在一个单一的项目中管理多个包变得更加简单和高效。

### 5. 性能优化

- **高效缓存机制**：`pnpm` 有一个高效的缓存机制，即使在连续的安装过程中也能保持较高的性能。

### 6. 更严格的项目结构和依赖管理

- **预防“幽灵”依赖**：`pnpm` 通过其结构化的 `node_modules` 确保项目不会意外依赖于未在 `package.json` 中声明的包，从而减少了因依赖问题引起的错误。

虽然 `pnpm` 提供了许多优势，但最佳的包管理器选择依然取决于项目的具体需求、团队的习惯以及现有的基础设施。不过，对于追求高效率和更好资源管理的项目，`pnpm` 往往是一个非常值得考虑的选择。


## 浏览器处理AJAX请求和渲染页面是同一个进程吗，为什么

不，浏览器处理AJAX请求和渲染页面并不是在同一个进程中完成的。这是因为现代浏览器的设计是多进程的，以提高性能和稳定性。

在浏览器中，有多个进程共同工作，包括：

1. 浏览器进程：主要负责界面显示、用户交互、子进程的管理，同时提供存储等功能。

2. 渲染进程：主要负责页面渲染，脚本执行，事件处理等。

3. 网络进程：主要负责页面的网络资源加载。

4. 插件进程：主要负责插件的运行，因插件容易崩溃，所以需要通过插件进程来隔离，以确保插件进程崩溃不会影响浏览器和页面的正常工作。

当你发起一个AJAX请求时，这个请求是由网络进程处理的，而渲染页面则是由渲染进程处理的。这种设计使得浏览器可以并行处理这两个任务，提高了浏览器的响应速度和用户体验。同时，如果一个进程崩溃，它不会影响到其他进程，这也提高了浏览器的稳定性。
